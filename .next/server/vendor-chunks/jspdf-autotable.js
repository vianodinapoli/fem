"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jspdf-autotable";
exports.ids = ["vendor-chunks/jspdf-autotable"];
exports.modules = {

/***/ "(ssr)/./node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: () => (/* binding */ Cell),\n/* harmony export */   CellHookData: () => (/* binding */ CellHookData),\n/* harmony export */   Column: () => (/* binding */ Column),\n/* harmony export */   HookData: () => (/* binding */ HookData),\n/* harmony export */   Row: () => (/* binding */ Row),\n/* harmony export */   Table: () => (/* binding */ Table),\n/* harmony export */   __createTable: () => (/* binding */ __createTable),\n/* harmony export */   __drawTable: () => (/* binding */ __drawTable),\n/* harmony export */   applyPlugin: () => (/* binding */ applyPlugin),\n/* harmony export */   autoTable: () => (/* binding */ autoTable),\n/* harmony export */   \"default\": () => (/* binding */ autoTable)\n/* harmony export */ });\n/**\n * Improved text function with halign and valign support\n * Inspiration from: http://stackoverflow.com/questions/28327510/align-text-right-using-jspdf/28433113#28433113\n */ function autoTableText(text, x, y, styles, doc) {\n    styles = styles || {};\n    var PHYSICAL_LINE_HEIGHT = 1.15;\n    var k = doc.internal.scaleFactor;\n    var fontSize = doc.internal.getFontSize() / k;\n    var lineHeightFactor = doc.getLineHeightFactor ? doc.getLineHeightFactor() : PHYSICAL_LINE_HEIGHT;\n    var lineHeight = fontSize * lineHeightFactor;\n    var splitRegex = /\\r\\n|\\r|\\n/g;\n    var splitText = \"\";\n    var lineCount = 1;\n    if (styles.valign === \"middle\" || styles.valign === \"bottom\" || styles.halign === \"center\" || styles.halign === \"right\") {\n        splitText = typeof text === \"string\" ? text.split(splitRegex) : text;\n        lineCount = splitText.length || 1;\n    }\n    // Align the top\n    y += fontSize * (2 - PHYSICAL_LINE_HEIGHT);\n    if (styles.valign === \"middle\") y -= lineCount / 2 * lineHeight;\n    else if (styles.valign === \"bottom\") y -= lineCount * lineHeight;\n    if (styles.halign === \"center\" || styles.halign === \"right\") {\n        var alignSize = fontSize;\n        if (styles.halign === \"center\") alignSize *= 0.5;\n        if (splitText && lineCount >= 1) {\n            for(var iLine = 0; iLine < splitText.length; iLine++){\n                doc.text(splitText[iLine], x - doc.getStringUnitWidth(splitText[iLine]) * alignSize, y);\n                y += lineHeight;\n            }\n            return doc;\n        }\n        x -= doc.getStringUnitWidth(text) * alignSize;\n    }\n    if (styles.halign === \"justify\") {\n        doc.text(text, x, y, {\n            maxWidth: styles.maxWidth || 100,\n            align: \"justify\"\n        });\n    } else {\n        doc.text(text, x, y);\n    }\n    return doc;\n}\nvar globalDefaults = {};\nvar DocHandler = /** @class */ function() {\n    function DocHandler(jsPDFDocument) {\n        this.jsPDFDocument = jsPDFDocument;\n        this.userStyles = {\n            // Black for versions of jspdf without getTextColor\n            textColor: jsPDFDocument.getTextColor ? this.jsPDFDocument.getTextColor() : 0,\n            fontSize: jsPDFDocument.internal.getFontSize(),\n            fontStyle: jsPDFDocument.internal.getFont().fontStyle,\n            font: jsPDFDocument.internal.getFont().fontName,\n            // 0 for versions of jspdf without getLineWidth\n            lineWidth: jsPDFDocument.getLineWidth ? this.jsPDFDocument.getLineWidth() : 0,\n            // Black for versions of jspdf without getDrawColor\n            lineColor: jsPDFDocument.getDrawColor ? this.jsPDFDocument.getDrawColor() : 0\n        };\n    }\n    DocHandler.setDefaults = function(defaults, doc) {\n        if (doc === void 0) {\n            doc = null;\n        }\n        if (doc) {\n            doc.__autoTableDocumentDefaults = defaults;\n        } else {\n            globalDefaults = defaults;\n        }\n    };\n    DocHandler.unifyColor = function(c) {\n        if (Array.isArray(c)) {\n            return c;\n        } else if (typeof c === \"number\") {\n            return [\n                c,\n                c,\n                c\n            ];\n        } else if (typeof c === \"string\") {\n            return [\n                c\n            ];\n        } else {\n            return null;\n        }\n    };\n    DocHandler.prototype.applyStyles = function(styles, fontOnly) {\n        // Font style needs to be applied before font\n        // https://github.com/simonbengtsson/jsPDF-AutoTable/issues/632\n        var _a, _b, _c;\n        if (fontOnly === void 0) {\n            fontOnly = false;\n        }\n        if (styles.fontStyle && this.jsPDFDocument.setFontStyle) {\n            this.jsPDFDocument.setFontStyle(styles.fontStyle);\n        }\n        var _d = this.jsPDFDocument.internal.getFont(), fontStyle = _d.fontStyle, fontName = _d.fontName;\n        if (styles.font) fontName = styles.font;\n        if (styles.fontStyle) {\n            fontStyle = styles.fontStyle;\n            var availableFontStyles = this.getFontList()[fontName];\n            if (availableFontStyles && availableFontStyles.indexOf(fontStyle) === -1 && this.jsPDFDocument.setFontStyle) {\n                // Common issue was that the default bold in headers\n                // made custom fonts not work. For example:\n                // https://github.com/simonbengtsson/jsPDF-AutoTable/issues/653\n                this.jsPDFDocument.setFontStyle(availableFontStyles[0]);\n                fontStyle = availableFontStyles[0];\n            }\n        }\n        this.jsPDFDocument.setFont(fontName, fontStyle);\n        if (styles.fontSize) this.jsPDFDocument.setFontSize(styles.fontSize);\n        if (fontOnly) {\n            return; // Performance improvement\n        }\n        var color = DocHandler.unifyColor(styles.fillColor);\n        if (color) (_a = this.jsPDFDocument).setFillColor.apply(_a, color);\n        color = DocHandler.unifyColor(styles.textColor);\n        if (color) (_b = this.jsPDFDocument).setTextColor.apply(_b, color);\n        color = DocHandler.unifyColor(styles.lineColor);\n        if (color) (_c = this.jsPDFDocument).setDrawColor.apply(_c, color);\n        if (typeof styles.lineWidth === \"number\") {\n            this.jsPDFDocument.setLineWidth(styles.lineWidth);\n        }\n    };\n    DocHandler.prototype.splitTextToSize = function(text, size, opts) {\n        return this.jsPDFDocument.splitTextToSize(text, size, opts);\n    };\n    /**\n     * Adds a rectangle to the PDF\n     * @param x Coordinate (in units declared at inception of PDF document) against left edge of the page\n     * @param y Coordinate (in units declared at inception of PDF document) against upper edge of the page\n     * @param width Width (in units declared at inception of PDF document)\n     * @param height Height (in units declared at inception of PDF document)\n     * @param fillStyle A string specifying the painting style or null. Valid styles include: 'S' [default] - stroke, 'F' - fill, and 'DF' (or 'FD') - fill then stroke.\n     */ DocHandler.prototype.rect = function(x, y, width, height, fillStyle) {\n        // null is excluded from fillStyle possible values because it isn't needed\n        // and is prone to bugs as it's used to postpone setting the style\n        // https://rawgit.com/MrRio/jsPDF/master/docs/jsPDF.html#rect\n        return this.jsPDFDocument.rect(x, y, width, height, fillStyle);\n    };\n    DocHandler.prototype.getLastAutoTable = function() {\n        return this.jsPDFDocument.lastAutoTable || null;\n    };\n    DocHandler.prototype.getTextWidth = function(text) {\n        return this.jsPDFDocument.getTextWidth(text);\n    };\n    DocHandler.prototype.getDocument = function() {\n        return this.jsPDFDocument;\n    };\n    DocHandler.prototype.setPage = function(page) {\n        this.jsPDFDocument.setPage(page);\n    };\n    DocHandler.prototype.addPage = function() {\n        return this.jsPDFDocument.addPage();\n    };\n    DocHandler.prototype.getFontList = function() {\n        return this.jsPDFDocument.getFontList();\n    };\n    DocHandler.prototype.getGlobalOptions = function() {\n        return globalDefaults || {};\n    };\n    DocHandler.prototype.getDocumentOptions = function() {\n        return this.jsPDFDocument.__autoTableDocumentDefaults || {};\n    };\n    DocHandler.prototype.pageSize = function() {\n        var pageSize = this.jsPDFDocument.internal.pageSize;\n        // JSPDF 1.4 uses get functions instead of properties on pageSize\n        if (pageSize.width == null) {\n            pageSize = {\n                width: pageSize.getWidth(),\n                height: pageSize.getHeight()\n            };\n        }\n        return pageSize;\n    };\n    DocHandler.prototype.scaleFactor = function() {\n        return this.jsPDFDocument.internal.scaleFactor;\n    };\n    DocHandler.prototype.getLineHeightFactor = function() {\n        var doc = this.jsPDFDocument;\n        return doc.getLineHeightFactor ? doc.getLineHeightFactor() : 1.15;\n    };\n    DocHandler.prototype.getLineHeight = function(fontSize) {\n        return fontSize / this.scaleFactor() * this.getLineHeightFactor();\n    };\n    DocHandler.prototype.pageNumber = function() {\n        var pageInfo = this.jsPDFDocument.internal.getCurrentPageInfo();\n        if (!pageInfo) {\n            // Only recent versions of jspdf has pageInfo\n            return this.jsPDFDocument.internal.getNumberOfPages();\n        }\n        return pageInfo.pageNumber;\n    };\n    return DocHandler;\n}();\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar HtmlRowInput = /** @class */ function(_super) {\n    __extends(HtmlRowInput, _super);\n    function HtmlRowInput(element) {\n        var _this = _super.call(this) || this;\n        _this._element = element;\n        return _this;\n    }\n    return HtmlRowInput;\n}(Array);\n// Base style for all themes\nfunction defaultStyles(scaleFactor) {\n    return {\n        font: \"helvetica\",\n        fontStyle: \"normal\",\n        overflow: \"linebreak\",\n        fillColor: false,\n        textColor: 20,\n        halign: \"left\",\n        valign: \"top\",\n        fontSize: 10,\n        cellPadding: 5 / scaleFactor,\n        lineColor: 200,\n        lineWidth: 0,\n        cellWidth: \"auto\",\n        minCellHeight: 0,\n        minCellWidth: 0\n    };\n}\nfunction getTheme(name) {\n    var themes = {\n        striped: {\n            table: {\n                fillColor: 255,\n                textColor: 80,\n                fontStyle: \"normal\"\n            },\n            head: {\n                textColor: 255,\n                fillColor: [\n                    41,\n                    128,\n                    185\n                ],\n                fontStyle: \"bold\"\n            },\n            body: {},\n            foot: {\n                textColor: 255,\n                fillColor: [\n                    41,\n                    128,\n                    185\n                ],\n                fontStyle: \"bold\"\n            },\n            alternateRow: {\n                fillColor: 245\n            }\n        },\n        grid: {\n            table: {\n                fillColor: 255,\n                textColor: 80,\n                fontStyle: \"normal\",\n                lineWidth: 0.1\n            },\n            head: {\n                textColor: 255,\n                fillColor: [\n                    26,\n                    188,\n                    156\n                ],\n                fontStyle: \"bold\",\n                lineWidth: 0\n            },\n            body: {},\n            foot: {\n                textColor: 255,\n                fillColor: [\n                    26,\n                    188,\n                    156\n                ],\n                fontStyle: \"bold\",\n                lineWidth: 0\n            },\n            alternateRow: {}\n        },\n        plain: {\n            head: {\n                fontStyle: \"bold\"\n            },\n            foot: {\n                fontStyle: \"bold\"\n            }\n        }\n    };\n    return themes[name];\n}\nfunction getStringWidth(text, styles, doc) {\n    doc.applyStyles(styles, true);\n    var textArr = Array.isArray(text) ? text : [\n        text\n    ];\n    var widestLineWidth = textArr.map(function(text) {\n        return doc.getTextWidth(text);\n    }).reduce(function(a, b) {\n        return Math.max(a, b);\n    }, 0);\n    return widestLineWidth;\n}\nfunction addTableBorder(doc, table, startPos, cursor) {\n    var lineWidth = table.settings.tableLineWidth;\n    var lineColor = table.settings.tableLineColor;\n    doc.applyStyles({\n        lineWidth: lineWidth,\n        lineColor: lineColor\n    });\n    var fillStyle = getFillStyle(lineWidth, false);\n    if (fillStyle) {\n        doc.rect(startPos.x, startPos.y, table.getWidth(doc.pageSize().width), cursor.y - startPos.y, fillStyle);\n    }\n}\nfunction getFillStyle(lineWidth, fillColor) {\n    var drawLine = lineWidth > 0;\n    var drawBackground = fillColor || fillColor === 0;\n    if (drawLine && drawBackground) {\n        return \"DF\"; // Fill then stroke\n    } else if (drawLine) {\n        return \"S\"; // Only stroke (transparent background)\n    } else if (drawBackground) {\n        return \"F\"; // Only fill, no stroke\n    } else {\n        return null;\n    }\n}\nfunction parseSpacing(value, defaultValue) {\n    var _a, _b, _c, _d;\n    value = value || defaultValue;\n    if (Array.isArray(value)) {\n        if (value.length >= 4) {\n            return {\n                top: value[0],\n                right: value[1],\n                bottom: value[2],\n                left: value[3]\n            };\n        } else if (value.length === 3) {\n            return {\n                top: value[0],\n                right: value[1],\n                bottom: value[2],\n                left: value[1]\n            };\n        } else if (value.length === 2) {\n            return {\n                top: value[0],\n                right: value[1],\n                bottom: value[0],\n                left: value[1]\n            };\n        } else if (value.length === 1) {\n            value = value[0];\n        } else {\n            value = defaultValue;\n        }\n    }\n    if (typeof value === \"object\") {\n        if (typeof value.vertical === \"number\") {\n            value.top = value.vertical;\n            value.bottom = value.vertical;\n        }\n        if (typeof value.horizontal === \"number\") {\n            value.right = value.horizontal;\n            value.left = value.horizontal;\n        }\n        return {\n            left: (_a = value.left) !== null && _a !== void 0 ? _a : defaultValue,\n            top: (_b = value.top) !== null && _b !== void 0 ? _b : defaultValue,\n            right: (_c = value.right) !== null && _c !== void 0 ? _c : defaultValue,\n            bottom: (_d = value.bottom) !== null && _d !== void 0 ? _d : defaultValue\n        };\n    }\n    if (typeof value !== \"number\") {\n        value = defaultValue;\n    }\n    return {\n        top: value,\n        right: value,\n        bottom: value,\n        left: value\n    };\n}\nfunction getPageAvailableWidth(doc, table) {\n    var margins = parseSpacing(table.settings.margin, 0);\n    return doc.pageSize().width - (margins.left + margins.right);\n}\n// Limitations\n// - No support for border spacing\n// - No support for transparency\nfunction parseCss(supportedFonts, element, scaleFactor, style, window1) {\n    var result = {};\n    var pxScaleFactor = 96 / 72;\n    var backgroundColor = parseColor(element, function(elem) {\n        return window1.getComputedStyle(elem)[\"backgroundColor\"];\n    });\n    if (backgroundColor != null) result.fillColor = backgroundColor;\n    var textColor = parseColor(element, function(elem) {\n        return window1.getComputedStyle(elem)[\"color\"];\n    });\n    if (textColor != null) result.textColor = textColor;\n    var padding = parsePadding(style, scaleFactor);\n    if (padding) result.cellPadding = padding;\n    var borderColorSide = \"borderTopColor\";\n    var finalScaleFactor = pxScaleFactor * scaleFactor;\n    var btw = style.borderTopWidth;\n    if (style.borderBottomWidth === btw && style.borderRightWidth === btw && style.borderLeftWidth === btw) {\n        var borderWidth = (parseFloat(btw) || 0) / finalScaleFactor;\n        if (borderWidth) result.lineWidth = borderWidth;\n    } else {\n        result.lineWidth = {\n            top: (parseFloat(style.borderTopWidth) || 0) / finalScaleFactor,\n            right: (parseFloat(style.borderRightWidth) || 0) / finalScaleFactor,\n            bottom: (parseFloat(style.borderBottomWidth) || 0) / finalScaleFactor,\n            left: (parseFloat(style.borderLeftWidth) || 0) / finalScaleFactor\n        };\n        // Choose border color of first available side\n        // could be improved by supporting object as lineColor\n        if (!result.lineWidth.top) {\n            if (result.lineWidth.right) {\n                borderColorSide = \"borderRightColor\";\n            } else if (result.lineWidth.bottom) {\n                borderColorSide = \"borderBottomColor\";\n            } else if (result.lineWidth.left) {\n                borderColorSide = \"borderLeftColor\";\n            }\n        }\n    }\n    var borderColor = parseColor(element, function(elem) {\n        return window1.getComputedStyle(elem)[borderColorSide];\n    });\n    if (borderColor != null) result.lineColor = borderColor;\n    var accepted = [\n        \"left\",\n        \"right\",\n        \"center\",\n        \"justify\"\n    ];\n    if (accepted.indexOf(style.textAlign) !== -1) {\n        result.halign = style.textAlign;\n    }\n    accepted = [\n        \"middle\",\n        \"bottom\",\n        \"top\"\n    ];\n    if (accepted.indexOf(style.verticalAlign) !== -1) {\n        result.valign = style.verticalAlign;\n    }\n    var res = parseInt(style.fontSize || \"\");\n    if (!isNaN(res)) result.fontSize = res / pxScaleFactor;\n    var fontStyle = parseFontStyle(style);\n    if (fontStyle) result.fontStyle = fontStyle;\n    var font = (style.fontFamily || \"\").toLowerCase();\n    if (supportedFonts.indexOf(font) !== -1) {\n        result.font = font;\n    }\n    return result;\n}\nfunction parseFontStyle(style) {\n    var res = \"\";\n    if (style.fontWeight === \"bold\" || style.fontWeight === \"bolder\" || parseInt(style.fontWeight) >= 700) {\n        res = \"bold\";\n    }\n    if (style.fontStyle === \"italic\" || style.fontStyle === \"oblique\") {\n        res += \"italic\";\n    }\n    return res;\n}\nfunction parseColor(element, styleGetter) {\n    var cssColor = realColor(element, styleGetter);\n    if (!cssColor) return null;\n    var rgba = cssColor.match(/^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d*\\.?\\d*))?\\)$/);\n    if (!rgba || !Array.isArray(rgba)) {\n        return null;\n    }\n    var color = [\n        parseInt(rgba[1]),\n        parseInt(rgba[2]),\n        parseInt(rgba[3])\n    ];\n    var alpha = parseInt(rgba[4]);\n    if (alpha === 0 || isNaN(color[0]) || isNaN(color[1]) || isNaN(color[2])) {\n        return null;\n    }\n    return color;\n}\nfunction realColor(elem, styleGetter) {\n    var bg = styleGetter(elem);\n    if (bg === \"rgba(0, 0, 0, 0)\" || bg === \"transparent\" || bg === \"initial\" || bg === \"inherit\") {\n        if (elem.parentElement == null) {\n            return null;\n        }\n        return realColor(elem.parentElement, styleGetter);\n    } else {\n        return bg;\n    }\n}\nfunction parsePadding(style, scaleFactor) {\n    var val = [\n        style.paddingTop,\n        style.paddingRight,\n        style.paddingBottom,\n        style.paddingLeft\n    ];\n    var pxScaleFactor = 96 / (72 / scaleFactor);\n    var linePadding = (parseInt(style.lineHeight) - parseInt(style.fontSize)) / scaleFactor / 2;\n    var inputPadding = val.map(function(n) {\n        return parseInt(n || \"0\") / pxScaleFactor;\n    });\n    var padding = parseSpacing(inputPadding, 0);\n    if (linePadding > padding.top) {\n        padding.top = linePadding;\n    }\n    if (linePadding > padding.bottom) {\n        padding.bottom = linePadding;\n    }\n    return padding;\n}\nfunction parseHtml(doc, input, window1, includeHiddenHtml, useCss) {\n    var _a, _b;\n    if (includeHiddenHtml === void 0) {\n        includeHiddenHtml = false;\n    }\n    if (useCss === void 0) {\n        useCss = false;\n    }\n    var tableElement;\n    if (typeof input === \"string\") {\n        tableElement = window1.document.querySelector(input);\n    } else {\n        tableElement = input;\n    }\n    var supportedFonts = Object.keys(doc.getFontList());\n    var scaleFactor = doc.scaleFactor();\n    var head = [], body = [], foot = [];\n    if (!tableElement) {\n        console.error(\"Html table could not be found with input: \", input);\n        return {\n            head: head,\n            body: body,\n            foot: foot\n        };\n    }\n    for(var i = 0; i < tableElement.rows.length; i++){\n        var element = tableElement.rows[i];\n        var tagName = (_b = (_a = element === null || element === void 0 ? void 0 : element.parentElement) === null || _a === void 0 ? void 0 : _a.tagName) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n        var row = parseRowContent(supportedFonts, scaleFactor, window1, element, includeHiddenHtml, useCss);\n        if (!row) continue;\n        if (tagName === \"thead\") {\n            head.push(row);\n        } else if (tagName === \"tfoot\") {\n            foot.push(row);\n        } else {\n            // Add to body both if parent is tbody or table\n            body.push(row);\n        }\n    }\n    return {\n        head: head,\n        body: body,\n        foot: foot\n    };\n}\nfunction parseRowContent(supportedFonts, scaleFactor, window1, row, includeHidden, useCss) {\n    var resultRow = new HtmlRowInput(row);\n    for(var i = 0; i < row.cells.length; i++){\n        var cell = row.cells[i];\n        var style_1 = window1.getComputedStyle(cell);\n        if (includeHidden || style_1.display !== \"none\") {\n            var cellStyles = void 0;\n            if (useCss) {\n                cellStyles = parseCss(supportedFonts, cell, scaleFactor, style_1, window1);\n            }\n            resultRow.push({\n                rowSpan: cell.rowSpan,\n                colSpan: cell.colSpan,\n                styles: cellStyles,\n                _element: cell,\n                content: parseCellContent(cell)\n            });\n        }\n    }\n    var style = window1.getComputedStyle(row);\n    if (resultRow.length > 0 && (includeHidden || style.display !== \"none\")) {\n        return resultRow;\n    }\n}\nfunction parseCellContent(orgCell) {\n    // Work on cloned node to make sure no changes are applied to html table\n    var cell = orgCell.cloneNode(true);\n    // Remove extra space and line breaks in markup to make it more similar to\n    // what would be shown in html\n    cell.innerHTML = cell.innerHTML.replace(/\\n/g, \"\").replace(/ +/g, \" \");\n    // Preserve <br> tags as line breaks in the pdf\n    cell.innerHTML = cell.innerHTML.split(/<br.*?>/) //start with '<br' and ends with '>'.\n    .map(function(part) {\n        return part.trim();\n    }).join(\"\\n\");\n    // innerText for ie\n    return cell.innerText || cell.textContent || \"\";\n}\nfunction validateInput(global, document, current) {\n    for(var _i = 0, _a = [\n        global,\n        document,\n        current\n    ]; _i < _a.length; _i++){\n        var options = _a[_i];\n        if (options && typeof options !== \"object\") {\n            console.error(\"The options parameter should be of type object, is: \" + typeof options);\n        }\n        if (options.startY && typeof options.startY !== \"number\") {\n            console.error(\"Invalid value for startY option\", options.startY);\n            delete options.startY;\n        }\n    }\n}\n/* eslint-disable @typescript-eslint/no-unused-vars */ // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nfunction assign(target, s, s1, s2, s3) {\n    if (target == null) {\n        throw new TypeError(\"Cannot convert undefined or null to object\");\n    }\n    var to = Object(target);\n    for(var index = 1; index < arguments.length; index++){\n        // eslint-disable-next-line prefer-rest-params\n        var nextSource = arguments[index];\n        if (nextSource != null) {\n            // Skip over if undefined or null\n            for(var nextKey in nextSource){\n                // Avoid bugs when hasOwnProperty is shadowed\n                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                    to[nextKey] = nextSource[nextKey];\n                }\n            }\n        }\n    }\n    return to;\n}\nfunction parseInput(d, current) {\n    var doc = new DocHandler(d);\n    var document = doc.getDocumentOptions();\n    var global = doc.getGlobalOptions();\n    validateInput(global, document, current);\n    var options = assign({}, global, document, current);\n    var win;\n    if (false) {}\n    var styles = parseStyles(global, document, current);\n    var hooks = parseHooks(global, document, current);\n    var settings = parseSettings(doc, options);\n    var content = parseContent$1(doc, options, win);\n    return {\n        id: current.tableId,\n        content: content,\n        hooks: hooks,\n        styles: styles,\n        settings: settings\n    };\n}\nfunction parseStyles(gInput, dInput, cInput) {\n    var styleOptions = {\n        styles: {},\n        headStyles: {},\n        bodyStyles: {},\n        footStyles: {},\n        alternateRowStyles: {},\n        columnStyles: {}\n    };\n    var _loop_1 = function(prop) {\n        if (prop === \"columnStyles\") {\n            var global_1 = gInput[prop];\n            var document_1 = dInput[prop];\n            var current = cInput[prop];\n            styleOptions.columnStyles = assign({}, global_1, document_1, current);\n        } else {\n            var allOptions = [\n                gInput,\n                dInput,\n                cInput\n            ];\n            var styles = allOptions.map(function(opts) {\n                return opts[prop] || {};\n            });\n            styleOptions[prop] = assign({}, styles[0], styles[1], styles[2]);\n        }\n    };\n    for(var _i = 0, _a = Object.keys(styleOptions); _i < _a.length; _i++){\n        var prop = _a[_i];\n        _loop_1(prop);\n    }\n    return styleOptions;\n}\nfunction parseHooks(global, document, current) {\n    var allOptions = [\n        global,\n        document,\n        current\n    ];\n    var result = {\n        didParseCell: [],\n        willDrawCell: [],\n        didDrawCell: [],\n        willDrawPage: [],\n        didDrawPage: []\n    };\n    for(var _i = 0, allOptions_1 = allOptions; _i < allOptions_1.length; _i++){\n        var options = allOptions_1[_i];\n        if (options.didParseCell) result.didParseCell.push(options.didParseCell);\n        if (options.willDrawCell) result.willDrawCell.push(options.willDrawCell);\n        if (options.didDrawCell) result.didDrawCell.push(options.didDrawCell);\n        if (options.willDrawPage) result.willDrawPage.push(options.willDrawPage);\n        if (options.didDrawPage) result.didDrawPage.push(options.didDrawPage);\n    }\n    return result;\n}\nfunction parseSettings(doc, options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n    var margin = parseSpacing(options.margin, 40 / doc.scaleFactor());\n    var startY = (_a = getStartY(doc, options.startY)) !== null && _a !== void 0 ? _a : margin.top;\n    var showFoot;\n    if (options.showFoot === true) {\n        showFoot = \"everyPage\";\n    } else if (options.showFoot === false) {\n        showFoot = \"never\";\n    } else {\n        showFoot = (_b = options.showFoot) !== null && _b !== void 0 ? _b : \"everyPage\";\n    }\n    var showHead;\n    if (options.showHead === true) {\n        showHead = \"everyPage\";\n    } else if (options.showHead === false) {\n        showHead = \"never\";\n    } else {\n        showHead = (_c = options.showHead) !== null && _c !== void 0 ? _c : \"everyPage\";\n    }\n    var useCss = (_d = options.useCss) !== null && _d !== void 0 ? _d : false;\n    var theme = options.theme || (useCss ? \"plain\" : \"striped\");\n    var horizontalPageBreak = !!options.horizontalPageBreak;\n    var horizontalPageBreakRepeat = (_e = options.horizontalPageBreakRepeat) !== null && _e !== void 0 ? _e : null;\n    return {\n        includeHiddenHtml: (_f = options.includeHiddenHtml) !== null && _f !== void 0 ? _f : false,\n        useCss: useCss,\n        theme: theme,\n        startY: startY,\n        margin: margin,\n        pageBreak: (_g = options.pageBreak) !== null && _g !== void 0 ? _g : \"auto\",\n        rowPageBreak: (_h = options.rowPageBreak) !== null && _h !== void 0 ? _h : \"auto\",\n        tableWidth: (_j = options.tableWidth) !== null && _j !== void 0 ? _j : \"auto\",\n        showHead: showHead,\n        showFoot: showFoot,\n        tableLineWidth: (_k = options.tableLineWidth) !== null && _k !== void 0 ? _k : 0,\n        tableLineColor: (_l = options.tableLineColor) !== null && _l !== void 0 ? _l : 200,\n        horizontalPageBreak: horizontalPageBreak,\n        horizontalPageBreakRepeat: horizontalPageBreakRepeat,\n        horizontalPageBreakBehaviour: (_m = options.horizontalPageBreakBehaviour) !== null && _m !== void 0 ? _m : \"afterAllRows\"\n    };\n}\nfunction getStartY(doc, userStartY) {\n    var previous = doc.getLastAutoTable();\n    var sf = doc.scaleFactor();\n    var currentPage = doc.pageNumber();\n    var isSamePageAsPreviousTable = false;\n    if (previous && previous.startPageNumber) {\n        var endingPage = previous.startPageNumber + previous.pageNumber - 1;\n        isSamePageAsPreviousTable = endingPage === currentPage;\n    }\n    if (typeof userStartY === \"number\") {\n        return userStartY;\n    } else if (userStartY == null || userStartY === false) {\n        if (isSamePageAsPreviousTable && (previous === null || previous === void 0 ? void 0 : previous.finalY) != null) {\n            // Some users had issues with overlapping tables when they used multiple\n            // tables without setting startY so setting it here to a sensible default.\n            return previous.finalY + 20 / sf;\n        }\n    }\n    return null;\n}\nfunction parseContent$1(doc, options, window1) {\n    var head = options.head || [];\n    var body = options.body || [];\n    var foot = options.foot || [];\n    if (options.html) {\n        var hidden = options.includeHiddenHtml;\n        if (window1) {\n            var htmlContent = parseHtml(doc, options.html, window1, hidden, options.useCss) || {};\n            head = htmlContent.head || head;\n            body = htmlContent.body || head;\n            foot = htmlContent.foot || head;\n        } else {\n            console.error(\"Cannot parse html in non browser environment\");\n        }\n    }\n    var columns = options.columns || parseColumns(head, body, foot);\n    return {\n        columns: columns,\n        head: head,\n        body: body,\n        foot: foot\n    };\n}\nfunction parseColumns(head, body, foot) {\n    var firstRow = head[0] || body[0] || foot[0] || [];\n    var result = [];\n    Object.keys(firstRow).filter(function(key) {\n        return key !== \"_element\";\n    }).forEach(function(key) {\n        var colSpan = 1;\n        var input;\n        if (Array.isArray(firstRow)) {\n            input = firstRow[parseInt(key)];\n        } else {\n            input = firstRow[key];\n        }\n        if (typeof input === \"object\" && !Array.isArray(input)) {\n            colSpan = (input === null || input === void 0 ? void 0 : input.colSpan) || 1;\n        }\n        for(var i = 0; i < colSpan; i++){\n            var id = void 0;\n            if (Array.isArray(firstRow)) {\n                id = result.length;\n            } else {\n                id = key + (i > 0 ? \"_\".concat(i) : \"\");\n            }\n            var rowResult = {\n                dataKey: id\n            };\n            result.push(rowResult);\n        }\n    });\n    return result;\n}\nvar HookData = /** @class */ function() {\n    function HookData(doc, table, cursor) {\n        this.table = table;\n        this.pageNumber = table.pageNumber;\n        this.settings = table.settings;\n        this.cursor = cursor;\n        this.doc = doc.getDocument();\n    }\n    return HookData;\n}();\nvar CellHookData = /** @class */ function(_super) {\n    __extends(CellHookData, _super);\n    function CellHookData(doc, table, cell, row, column, cursor) {\n        var _this = _super.call(this, doc, table, cursor) || this;\n        _this.cell = cell;\n        _this.row = row;\n        _this.column = column;\n        _this.section = row.section;\n        return _this;\n    }\n    return CellHookData;\n}(HookData);\nvar Table = /** @class */ function() {\n    function Table(input, content) {\n        this.pageNumber = 1;\n        this.id = input.id;\n        this.settings = input.settings;\n        this.styles = input.styles;\n        this.hooks = input.hooks;\n        this.columns = content.columns;\n        this.head = content.head;\n        this.body = content.body;\n        this.foot = content.foot;\n    }\n    Table.prototype.getHeadHeight = function(columns) {\n        return this.head.reduce(function(acc, row) {\n            return acc + row.getMaxCellHeight(columns);\n        }, 0);\n    };\n    Table.prototype.getFootHeight = function(columns) {\n        return this.foot.reduce(function(acc, row) {\n            return acc + row.getMaxCellHeight(columns);\n        }, 0);\n    };\n    Table.prototype.allRows = function() {\n        return this.head.concat(this.body).concat(this.foot);\n    };\n    Table.prototype.callCellHooks = function(doc, handlers, cell, row, column, cursor) {\n        for(var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++){\n            var handler = handlers_1[_i];\n            var data = new CellHookData(doc, this, cell, row, column, cursor);\n            var result = handler(data) === false;\n            // Make sure text is always string[] since user can assign string\n            cell.text = Array.isArray(cell.text) ? cell.text : [\n                cell.text\n            ];\n            if (result) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Table.prototype.callEndPageHooks = function(doc, cursor) {\n        doc.applyStyles(doc.userStyles);\n        for(var _i = 0, _a = this.hooks.didDrawPage; _i < _a.length; _i++){\n            var handler = _a[_i];\n            handler(new HookData(doc, this, cursor));\n        }\n    };\n    Table.prototype.callWillDrawPageHooks = function(doc, cursor) {\n        for(var _i = 0, _a = this.hooks.willDrawPage; _i < _a.length; _i++){\n            var handler = _a[_i];\n            handler(new HookData(doc, this, cursor));\n        }\n    };\n    Table.prototype.getWidth = function(pageWidth) {\n        if (typeof this.settings.tableWidth === \"number\") {\n            return this.settings.tableWidth;\n        } else if (this.settings.tableWidth === \"wrap\") {\n            var wrappedWidth = this.columns.reduce(function(total, col) {\n                return total + col.wrappedWidth;\n            }, 0);\n            return wrappedWidth;\n        } else {\n            var margin = this.settings.margin;\n            return pageWidth - margin.left - margin.right;\n        }\n    };\n    return Table;\n}();\nvar Row = /** @class */ function() {\n    function Row(raw, index, section, cells, spansMultiplePages) {\n        if (spansMultiplePages === void 0) {\n            spansMultiplePages = false;\n        }\n        this.height = 0;\n        this.raw = raw;\n        if (raw instanceof HtmlRowInput) {\n            this.raw = raw._element;\n            this.element = raw._element;\n        }\n        this.index = index;\n        this.section = section;\n        this.cells = cells;\n        this.spansMultiplePages = spansMultiplePages;\n    }\n    Row.prototype.getMaxCellHeight = function(columns) {\n        var _this = this;\n        return columns.reduce(function(acc, column) {\n            var _a;\n            return Math.max(acc, ((_a = _this.cells[column.index]) === null || _a === void 0 ? void 0 : _a.height) || 0);\n        }, 0);\n    };\n    Row.prototype.hasRowSpan = function(columns) {\n        var _this = this;\n        return columns.filter(function(column) {\n            var cell = _this.cells[column.index];\n            if (!cell) return false;\n            return cell.rowSpan > 1;\n        }).length > 0;\n    };\n    Row.prototype.canEntireRowFit = function(height, columns) {\n        return this.getMaxCellHeight(columns) <= height;\n    };\n    Row.prototype.getMinimumRowHeight = function(columns, doc) {\n        var _this = this;\n        return columns.reduce(function(acc, column) {\n            var cell = _this.cells[column.index];\n            if (!cell) return 0;\n            var lineHeight = doc.getLineHeight(cell.styles.fontSize);\n            var vPadding = cell.padding(\"vertical\");\n            var oneRowHeight = vPadding + lineHeight;\n            return oneRowHeight > acc ? oneRowHeight : acc;\n        }, 0);\n    };\n    return Row;\n}();\nvar Cell = /** @class */ function() {\n    function Cell(raw, styles, section) {\n        var _a;\n        this.contentHeight = 0;\n        this.contentWidth = 0;\n        this.wrappedWidth = 0;\n        this.minReadableWidth = 0;\n        this.minWidth = 0;\n        this.width = 0;\n        this.height = 0;\n        this.x = 0;\n        this.y = 0;\n        this.styles = styles;\n        this.section = section;\n        this.raw = raw;\n        var content = raw;\n        if (raw != null && typeof raw === \"object\" && !Array.isArray(raw)) {\n            this.rowSpan = raw.rowSpan || 1;\n            this.colSpan = raw.colSpan || 1;\n            content = (_a = raw.content) !== null && _a !== void 0 ? _a : raw;\n            if (raw._element) {\n                this.raw = raw._element;\n            }\n        } else {\n            this.rowSpan = 1;\n            this.colSpan = 1;\n        }\n        // Stringify 0 and false, but not undefined or null\n        var text = content != null ? \"\" + content : \"\";\n        var splitRegex = /\\r\\n|\\r|\\n/g;\n        this.text = text.split(splitRegex);\n    }\n    Cell.prototype.getTextPos = function() {\n        var y;\n        if (this.styles.valign === \"top\") {\n            y = this.y + this.padding(\"top\");\n        } else if (this.styles.valign === \"bottom\") {\n            y = this.y + this.height - this.padding(\"bottom\");\n        } else {\n            var netHeight = this.height - this.padding(\"vertical\");\n            y = this.y + netHeight / 2 + this.padding(\"top\");\n        }\n        var x;\n        if (this.styles.halign === \"right\") {\n            x = this.x + this.width - this.padding(\"right\");\n        } else if (this.styles.halign === \"center\") {\n            var netWidth = this.width - this.padding(\"horizontal\");\n            x = this.x + netWidth / 2 + this.padding(\"left\");\n        } else {\n            x = this.x + this.padding(\"left\");\n        }\n        return {\n            x: x,\n            y: y\n        };\n    };\n    // TODO (v4): replace parameters with only (lineHeight)\n    Cell.prototype.getContentHeight = function(scaleFactor, lineHeightFactor) {\n        if (lineHeightFactor === void 0) {\n            lineHeightFactor = 1.15;\n        }\n        var lineCount = Array.isArray(this.text) ? this.text.length : 1;\n        var lineHeight = this.styles.fontSize / scaleFactor * lineHeightFactor;\n        var height = lineCount * lineHeight + this.padding(\"vertical\");\n        return Math.max(height, this.styles.minCellHeight);\n    };\n    Cell.prototype.padding = function(name) {\n        var padding = parseSpacing(this.styles.cellPadding, 0);\n        if (name === \"vertical\") {\n            return padding.top + padding.bottom;\n        } else if (name === \"horizontal\") {\n            return padding.left + padding.right;\n        } else {\n            return padding[name];\n        }\n    };\n    return Cell;\n}();\nvar Column = /** @class */ function() {\n    function Column(dataKey, raw, index) {\n        this.wrappedWidth = 0;\n        this.minReadableWidth = 0;\n        this.minWidth = 0;\n        this.width = 0;\n        this.dataKey = dataKey;\n        this.raw = raw;\n        this.index = index;\n    }\n    Column.prototype.getMaxCustomCellWidth = function(table) {\n        var max = 0;\n        for(var _i = 0, _a = table.allRows(); _i < _a.length; _i++){\n            var row = _a[_i];\n            var cell = row.cells[this.index];\n            if (cell && typeof cell.styles.cellWidth === \"number\") {\n                max = Math.max(max, cell.styles.cellWidth);\n            }\n        }\n        return max;\n    };\n    return Column;\n}();\n/**\n * Calculate the column widths\n */ function calculateWidths(doc, table) {\n    calculate(doc, table);\n    var resizableColumns = [];\n    var initialTableWidth = 0;\n    table.columns.forEach(function(column) {\n        var customWidth = column.getMaxCustomCellWidth(table);\n        if (customWidth) {\n            // final column width\n            column.width = customWidth;\n        } else {\n            // initial column width (will be resized)\n            column.width = column.wrappedWidth;\n            resizableColumns.push(column);\n        }\n        initialTableWidth += column.width;\n    });\n    // width difference that needs to be distributed\n    var resizeWidth = table.getWidth(doc.pageSize().width) - initialTableWidth;\n    // first resize attempt: with respect to minReadableWidth and minWidth\n    if (resizeWidth) {\n        resizeWidth = resizeColumns(resizableColumns, resizeWidth, function(column) {\n            return Math.max(column.minReadableWidth, column.minWidth);\n        });\n    }\n    // second resize attempt: ignore minReadableWidth but respect minWidth\n    if (resizeWidth) {\n        resizeWidth = resizeColumns(resizableColumns, resizeWidth, function(column) {\n            return column.minWidth;\n        });\n    }\n    resizeWidth = Math.abs(resizeWidth);\n    if (!table.settings.horizontalPageBreak && resizeWidth > 0.1 / doc.scaleFactor()) {\n        // Table can't get smaller due to custom-width or minWidth restrictions\n        // We can't really do much here. Up to user to for example\n        // reduce font size, increase page size or remove custom cell widths\n        // to allow more columns to be reduced in size\n        resizeWidth = resizeWidth < 1 ? resizeWidth : Math.round(resizeWidth);\n        console.warn(\"Of the table content, \".concat(resizeWidth, \" units width could not fit page\"));\n    }\n    applyColSpans(table);\n    fitContent(table, doc);\n    applyRowSpans(table);\n}\nfunction calculate(doc, table) {\n    var sf = doc.scaleFactor();\n    var horizontalPageBreak = table.settings.horizontalPageBreak;\n    var availablePageWidth = getPageAvailableWidth(doc, table);\n    table.allRows().forEach(function(row) {\n        for(var _i = 0, _a = table.columns; _i < _a.length; _i++){\n            var column = _a[_i];\n            var cell = row.cells[column.index];\n            if (!cell) continue;\n            var hooks = table.hooks.didParseCell;\n            table.callCellHooks(doc, hooks, cell, row, column, null);\n            var padding = cell.padding(\"horizontal\");\n            cell.contentWidth = getStringWidth(cell.text, cell.styles, doc) + padding;\n            // Using [^\\S\\u00A0] instead of \\s ensures that we split the text on all\n            // whitespace except non-breaking spaces (\\u00A0). We need to preserve\n            // them in the split process to ensure correct word separation and width\n            // calculation.\n            var longestWordWidth = getStringWidth(cell.text.join(\" \").split(/[^\\S\\u00A0]+/), cell.styles, doc);\n            cell.minReadableWidth = longestWordWidth + cell.padding(\"horizontal\");\n            if (typeof cell.styles.cellWidth === \"number\") {\n                cell.minWidth = cell.styles.cellWidth;\n                cell.wrappedWidth = cell.styles.cellWidth;\n            } else if (cell.styles.cellWidth === \"wrap\" || horizontalPageBreak === true) {\n                // cell width should not be more than available page width\n                if (cell.contentWidth > availablePageWidth) {\n                    cell.minWidth = availablePageWidth;\n                    cell.wrappedWidth = availablePageWidth;\n                } else {\n                    cell.minWidth = cell.contentWidth;\n                    cell.wrappedWidth = cell.contentWidth;\n                }\n            } else {\n                // auto\n                var defaultMinWidth = 10 / sf;\n                cell.minWidth = cell.styles.minCellWidth || defaultMinWidth;\n                cell.wrappedWidth = cell.contentWidth;\n                if (cell.minWidth > cell.wrappedWidth) {\n                    cell.wrappedWidth = cell.minWidth;\n                }\n            }\n        }\n    });\n    table.allRows().forEach(function(row) {\n        for(var _i = 0, _a = table.columns; _i < _a.length; _i++){\n            var column = _a[_i];\n            var cell = row.cells[column.index];\n            // For now we ignore the minWidth and wrappedWidth of colspan cells when calculating colspan widths.\n            // Could probably be improved upon however.\n            if (cell && cell.colSpan === 1) {\n                column.wrappedWidth = Math.max(column.wrappedWidth, cell.wrappedWidth);\n                column.minWidth = Math.max(column.minWidth, cell.minWidth);\n                column.minReadableWidth = Math.max(column.minReadableWidth, cell.minReadableWidth);\n            } else {\n                // Respect cellWidth set in columnStyles even if there is no cells for this column\n                // or if the column only have colspan cells. Since the width of colspan cells\n                // does not affect the width of columns, setting columnStyles cellWidth enables the\n                // user to at least do it manually.\n                // Note that this is not perfect for now since for example row and table styles are\n                // not accounted for\n                var columnStyles = table.styles.columnStyles[column.dataKey] || table.styles.columnStyles[column.index] || {};\n                var cellWidth = columnStyles.cellWidth || columnStyles.minCellWidth;\n                if (cellWidth && typeof cellWidth === \"number\") {\n                    column.minWidth = cellWidth;\n                    column.wrappedWidth = cellWidth;\n                }\n            }\n            if (cell) {\n                // Make sure all columns get at least min width even though width calculations are not based on them\n                if (cell.colSpan > 1 && !column.minWidth) {\n                    column.minWidth = cell.minWidth;\n                }\n                if (cell.colSpan > 1 && !column.wrappedWidth) {\n                    column.wrappedWidth = cell.minWidth;\n                }\n            }\n        }\n    });\n}\n/**\n * Distribute resizeWidth on passed resizable columns\n */ function resizeColumns(columns, resizeWidth, getMinWidth) {\n    var initialResizeWidth = resizeWidth;\n    var sumWrappedWidth = columns.reduce(function(acc, column) {\n        return acc + column.wrappedWidth;\n    }, 0);\n    for(var i = 0; i < columns.length; i++){\n        var column = columns[i];\n        var ratio = column.wrappedWidth / sumWrappedWidth;\n        var suggestedChange = initialResizeWidth * ratio;\n        var suggestedWidth = column.width + suggestedChange;\n        var minWidth = getMinWidth(column);\n        var newWidth = suggestedWidth < minWidth ? minWidth : suggestedWidth;\n        resizeWidth -= newWidth - column.width;\n        column.width = newWidth;\n    }\n    resizeWidth = Math.round(resizeWidth * 1e10) / 1e10;\n    // Run the resizer again if there's remaining width needs\n    // to be distributed and there're columns that can be resized\n    if (resizeWidth) {\n        var resizableColumns = columns.filter(function(column) {\n            return resizeWidth < 0 ? column.width > getMinWidth(column) // check if column can shrink\n             : true; // check if column can grow\n        });\n        if (resizableColumns.length) {\n            resizeWidth = resizeColumns(resizableColumns, resizeWidth, getMinWidth);\n        }\n    }\n    return resizeWidth;\n}\nfunction applyRowSpans(table) {\n    var rowSpanCells = {};\n    var colRowSpansLeft = 1;\n    var all = table.allRows();\n    for(var rowIndex = 0; rowIndex < all.length; rowIndex++){\n        var row = all[rowIndex];\n        for(var _i = 0, _a = table.columns; _i < _a.length; _i++){\n            var column = _a[_i];\n            var data = rowSpanCells[column.index];\n            if (colRowSpansLeft > 1) {\n                colRowSpansLeft--;\n                delete row.cells[column.index];\n            } else if (data) {\n                data.cell.height += row.height;\n                colRowSpansLeft = data.cell.colSpan;\n                delete row.cells[column.index];\n                data.left--;\n                if (data.left <= 1) {\n                    delete rowSpanCells[column.index];\n                }\n            } else {\n                var cell = row.cells[column.index];\n                if (!cell) {\n                    continue;\n                }\n                cell.height = row.height;\n                if (cell.rowSpan > 1) {\n                    var remaining = all.length - rowIndex;\n                    var left = cell.rowSpan > remaining ? remaining : cell.rowSpan;\n                    rowSpanCells[column.index] = {\n                        cell: cell,\n                        left: left,\n                        row: row\n                    };\n                }\n            }\n        }\n    }\n}\nfunction applyColSpans(table) {\n    var all = table.allRows();\n    for(var rowIndex = 0; rowIndex < all.length; rowIndex++){\n        var row = all[rowIndex];\n        var colSpanCell = null;\n        var combinedColSpanWidth = 0;\n        var colSpansLeft = 0;\n        for(var columnIndex = 0; columnIndex < table.columns.length; columnIndex++){\n            var column = table.columns[columnIndex];\n            // Width and colspan\n            colSpansLeft -= 1;\n            if (colSpansLeft > 1 && table.columns[columnIndex + 1]) {\n                combinedColSpanWidth += column.width;\n                delete row.cells[column.index];\n            } else if (colSpanCell) {\n                var cell = colSpanCell;\n                delete row.cells[column.index];\n                colSpanCell = null;\n                cell.width = column.width + combinedColSpanWidth;\n            } else {\n                var cell = row.cells[column.index];\n                if (!cell) continue;\n                colSpansLeft = cell.colSpan;\n                combinedColSpanWidth = 0;\n                if (cell.colSpan > 1) {\n                    colSpanCell = cell;\n                    combinedColSpanWidth += column.width;\n                    continue;\n                }\n                cell.width = column.width + combinedColSpanWidth;\n            }\n        }\n    }\n}\nfunction fitContent(table, doc) {\n    var rowSpanHeight = {\n        count: 0,\n        height: 0\n    };\n    for(var _i = 0, _a = table.allRows(); _i < _a.length; _i++){\n        var row = _a[_i];\n        for(var _b = 0, _c = table.columns; _b < _c.length; _b++){\n            var column = _c[_b];\n            var cell = row.cells[column.index];\n            if (!cell) continue;\n            doc.applyStyles(cell.styles, true);\n            var textSpace = cell.width - cell.padding(\"horizontal\");\n            if (cell.styles.overflow === \"linebreak\") {\n                // Add one pt to textSpace to fix rounding error\n                cell.text = doc.splitTextToSize(cell.text, textSpace + 1 / doc.scaleFactor(), {\n                    fontSize: cell.styles.fontSize\n                });\n            } else if (cell.styles.overflow === \"ellipsize\") {\n                cell.text = ellipsize(cell.text, textSpace, cell.styles, doc, \"...\");\n            } else if (cell.styles.overflow === \"hidden\") {\n                cell.text = ellipsize(cell.text, textSpace, cell.styles, doc, \"\");\n            } else if (typeof cell.styles.overflow === \"function\") {\n                var result = cell.styles.overflow(cell.text, textSpace);\n                if (typeof result === \"string\") {\n                    cell.text = [\n                        result\n                    ];\n                } else {\n                    cell.text = result;\n                }\n            }\n            cell.contentHeight = cell.getContentHeight(doc.scaleFactor(), doc.getLineHeightFactor());\n            var realContentHeight = cell.contentHeight / cell.rowSpan;\n            if (cell.rowSpan > 1 && rowSpanHeight.count * rowSpanHeight.height < realContentHeight * cell.rowSpan) {\n                rowSpanHeight = {\n                    height: realContentHeight,\n                    count: cell.rowSpan\n                };\n            } else if (rowSpanHeight && rowSpanHeight.count > 0) {\n                if (rowSpanHeight.height > realContentHeight) {\n                    realContentHeight = rowSpanHeight.height;\n                }\n            }\n            if (realContentHeight > row.height) {\n                row.height = realContentHeight;\n            }\n        }\n        rowSpanHeight.count--;\n    }\n}\nfunction ellipsize(text, width, styles, doc, overflow) {\n    return text.map(function(str) {\n        return ellipsizeStr(str, width, styles, doc, overflow);\n    });\n}\nfunction ellipsizeStr(text, width, styles, doc, overflow) {\n    var precision = 10000 * doc.scaleFactor();\n    width = Math.ceil(width * precision) / precision;\n    if (width >= getStringWidth(text, styles, doc)) {\n        return text;\n    }\n    while(width < getStringWidth(text + overflow, styles, doc)){\n        if (text.length <= 1) {\n            break;\n        }\n        text = text.substring(0, text.length - 1);\n    }\n    return text.trim() + overflow;\n}\nfunction createTable(jsPDFDoc, input) {\n    var doc = new DocHandler(jsPDFDoc);\n    var content = parseContent(input, doc.scaleFactor());\n    var table = new Table(input, content);\n    calculateWidths(doc, table);\n    doc.applyStyles(doc.userStyles);\n    return table;\n}\nfunction parseContent(input, sf) {\n    var content = input.content;\n    var columns = createColumns(content.columns);\n    // If no head or foot is set, try generating it with content from columns\n    if (content.head.length === 0) {\n        var sectionRow = generateSectionRow(columns, \"head\");\n        if (sectionRow) content.head.push(sectionRow);\n    }\n    if (content.foot.length === 0) {\n        var sectionRow = generateSectionRow(columns, \"foot\");\n        if (sectionRow) content.foot.push(sectionRow);\n    }\n    var theme = input.settings.theme;\n    var styles = input.styles;\n    return {\n        columns: columns,\n        head: parseSection(\"head\", content.head, columns, styles, theme, sf),\n        body: parseSection(\"body\", content.body, columns, styles, theme, sf),\n        foot: parseSection(\"foot\", content.foot, columns, styles, theme, sf)\n    };\n}\nfunction parseSection(sectionName, sectionRows, columns, styleProps, theme, scaleFactor) {\n    var rowSpansLeftForColumn = {};\n    var result = sectionRows.map(function(rawRow, rowIndex) {\n        var skippedRowForRowSpans = 0;\n        var cells = {};\n        var colSpansAdded = 0;\n        var columnSpansLeft = 0;\n        for(var _i = 0, columns_1 = columns; _i < columns_1.length; _i++){\n            var column = columns_1[_i];\n            if (rowSpansLeftForColumn[column.index] == null || rowSpansLeftForColumn[column.index].left === 0) {\n                if (columnSpansLeft === 0) {\n                    var rawCell = void 0;\n                    if (Array.isArray(rawRow)) {\n                        rawCell = rawRow[column.index - colSpansAdded - skippedRowForRowSpans];\n                    } else {\n                        rawCell = rawRow[column.dataKey];\n                    }\n                    var cellInputStyles = {};\n                    if (typeof rawCell === \"object\" && !Array.isArray(rawCell)) {\n                        cellInputStyles = (rawCell === null || rawCell === void 0 ? void 0 : rawCell.styles) || {};\n                    }\n                    var styles = cellStyles(sectionName, column, rowIndex, theme, styleProps, scaleFactor, cellInputStyles);\n                    var cell = new Cell(rawCell, styles, sectionName);\n                    // dataKey is not used internally no more but keep for\n                    // backwards compat in hooks\n                    cells[column.dataKey] = cell;\n                    cells[column.index] = cell;\n                    columnSpansLeft = cell.colSpan - 1;\n                    rowSpansLeftForColumn[column.index] = {\n                        left: cell.rowSpan - 1,\n                        times: columnSpansLeft\n                    };\n                } else {\n                    columnSpansLeft--;\n                    colSpansAdded++;\n                }\n            } else {\n                rowSpansLeftForColumn[column.index].left--;\n                columnSpansLeft = rowSpansLeftForColumn[column.index].times;\n                skippedRowForRowSpans++;\n            }\n        }\n        return new Row(rawRow, rowIndex, sectionName, cells);\n    });\n    return result;\n}\nfunction generateSectionRow(columns, section) {\n    var sectionRow = {};\n    columns.forEach(function(col) {\n        if (col.raw != null) {\n            var title = getSectionTitle(section, col.raw);\n            if (title != null) sectionRow[col.dataKey] = title;\n        }\n    });\n    return Object.keys(sectionRow).length > 0 ? sectionRow : null;\n}\nfunction getSectionTitle(section, column) {\n    if (section === \"head\") {\n        if (typeof column === \"object\") {\n            return column.header || null;\n        } else if (typeof column === \"string\" || typeof column === \"number\") {\n            return column;\n        }\n    } else if (section === \"foot\" && typeof column === \"object\") {\n        return column.footer;\n    }\n    return null;\n}\nfunction createColumns(columns) {\n    return columns.map(function(input, index) {\n        var _a;\n        var key;\n        if (typeof input === \"object\") {\n            key = (_a = input.dataKey) !== null && _a !== void 0 ? _a : index;\n        } else {\n            key = index;\n        }\n        return new Column(key, input, index);\n    });\n}\nfunction cellStyles(sectionName, column, rowIndex, themeName, styles, scaleFactor, cellInputStyles) {\n    var theme = getTheme(themeName);\n    var sectionStyles;\n    if (sectionName === \"head\") {\n        sectionStyles = styles.headStyles;\n    } else if (sectionName === \"body\") {\n        sectionStyles = styles.bodyStyles;\n    } else if (sectionName === \"foot\") {\n        sectionStyles = styles.footStyles;\n    }\n    var otherStyles = assign({}, theme.table, theme[sectionName], styles.styles, sectionStyles);\n    var columnStyles = styles.columnStyles[column.dataKey] || styles.columnStyles[column.index] || {};\n    var colStyles = sectionName === \"body\" ? columnStyles : {};\n    var rowStyles = sectionName === \"body\" && rowIndex % 2 === 0 ? assign({}, theme.alternateRow, styles.alternateRowStyles) : {};\n    var defaultStyle = defaultStyles(scaleFactor);\n    var themeStyles = assign({}, defaultStyle, otherStyles, rowStyles, colStyles);\n    return assign(themeStyles, cellInputStyles);\n}\n// get columns can be fit into page\nfunction getColumnsCanFitInPage(doc, table, config) {\n    var _a;\n    if (config === void 0) {\n        config = {};\n    }\n    // Get page width\n    var remainingWidth = getPageAvailableWidth(doc, table);\n    // Get column data key to repeat\n    var repeatColumnsMap = new Map();\n    var colIndexes = [];\n    var columns = [];\n    var horizontalPageBreakRepeat = [];\n    if (Array.isArray(table.settings.horizontalPageBreakRepeat)) {\n        horizontalPageBreakRepeat = table.settings.horizontalPageBreakRepeat;\n    // It can be a single value of type string or number (even number: 0)\n    } else if (typeof table.settings.horizontalPageBreakRepeat === \"string\" || typeof table.settings.horizontalPageBreakRepeat === \"number\") {\n        horizontalPageBreakRepeat = [\n            table.settings.horizontalPageBreakRepeat\n        ];\n    }\n    // Code to repeat the given column in split pages\n    horizontalPageBreakRepeat.forEach(function(field) {\n        var col = table.columns.find(function(item) {\n            return item.dataKey === field || item.index === field;\n        });\n        if (col && !repeatColumnsMap.has(col.index)) {\n            repeatColumnsMap.set(col.index, true);\n            colIndexes.push(col.index);\n            columns.push(table.columns[col.index]);\n            remainingWidth -= col.wrappedWidth;\n        }\n    });\n    var first = true;\n    var i = (_a = config === null || config === void 0 ? void 0 : config.start) !== null && _a !== void 0 ? _a : 0; // make sure couter is initiated outside the loop\n    while(i < table.columns.length){\n        // Prevent duplicates\n        if (repeatColumnsMap.has(i)) {\n            i++;\n            continue;\n        }\n        var colWidth = table.columns[i].wrappedWidth;\n        // Take at least one column even if it doesn't fit\n        if (first || remainingWidth >= colWidth) {\n            first = false;\n            colIndexes.push(i);\n            columns.push(table.columns[i]);\n            remainingWidth -= colWidth;\n        } else {\n            break;\n        }\n        i++;\n    }\n    return {\n        colIndexes: colIndexes,\n        columns: columns,\n        lastIndex: i - 1\n    };\n}\nfunction calculateAllColumnsCanFitInPage(doc, table) {\n    var allResults = [];\n    for(var i = 0; i < table.columns.length; i++){\n        var result = getColumnsCanFitInPage(doc, table, {\n            start: i\n        });\n        if (result.columns.length) {\n            allResults.push(result);\n            i = result.lastIndex;\n        }\n    }\n    return allResults;\n}\nfunction drawTable(jsPDFDoc, table) {\n    var settings = table.settings;\n    var startY = settings.startY;\n    var margin = settings.margin;\n    var cursor = {\n        x: margin.left,\n        y: startY\n    };\n    var sectionsHeight = table.getHeadHeight(table.columns) + table.getFootHeight(table.columns);\n    var minTableBottomPos = startY + margin.bottom + sectionsHeight;\n    if (settings.pageBreak === \"avoid\") {\n        var rows = table.body;\n        var tableHeight = rows.reduce(function(acc, row) {\n            return acc + row.height;\n        }, 0);\n        minTableBottomPos += tableHeight;\n    }\n    var doc = new DocHandler(jsPDFDoc);\n    if (settings.pageBreak === \"always\" || settings.startY != null && minTableBottomPos > doc.pageSize().height) {\n        nextPage(doc);\n        cursor.y = margin.top;\n    }\n    table.callWillDrawPageHooks(doc, cursor);\n    var startPos = assign({}, cursor);\n    table.startPageNumber = doc.pageNumber();\n    if (settings.horizontalPageBreak) {\n        // managed flow for split columns\n        printTableWithHorizontalPageBreak(doc, table, startPos, cursor);\n    } else {\n        // normal flow\n        doc.applyStyles(doc.userStyles);\n        if (settings.showHead === \"firstPage\" || settings.showHead === \"everyPage\") {\n            table.head.forEach(function(row) {\n                return printRow(doc, table, row, cursor, table.columns);\n            });\n        }\n        doc.applyStyles(doc.userStyles);\n        table.body.forEach(function(row, index) {\n            var isLastRow = index === table.body.length - 1;\n            printFullRow(doc, table, row, isLastRow, startPos, cursor, table.columns);\n        });\n        doc.applyStyles(doc.userStyles);\n        if (settings.showFoot === \"lastPage\" || settings.showFoot === \"everyPage\") {\n            table.foot.forEach(function(row) {\n                return printRow(doc, table, row, cursor, table.columns);\n            });\n        }\n    }\n    addTableBorder(doc, table, startPos, cursor);\n    table.callEndPageHooks(doc, cursor);\n    table.finalY = cursor.y;\n    jsPDFDoc.lastAutoTable = table;\n    doc.applyStyles(doc.userStyles);\n}\nfunction printTableWithHorizontalPageBreak(doc, table, startPos, cursor) {\n    // calculate width of columns and render only those which can fit into page\n    var allColumnsCanFitResult = calculateAllColumnsCanFitInPage(doc, table);\n    var settings = table.settings;\n    if (settings.horizontalPageBreakBehaviour === \"afterAllRows\") {\n        allColumnsCanFitResult.forEach(function(colsAndIndexes, index) {\n            doc.applyStyles(doc.userStyles);\n            // add page to print next columns in new page\n            if (index > 0) {\n                // When adding a page here, make sure not to print the footers\n                // because they were already printed before on this same loop\n                addPage(doc, table, startPos, cursor, colsAndIndexes.columns, true);\n            } else {\n                // print head for selected columns\n                printHead(doc, table, cursor, colsAndIndexes.columns);\n            }\n            // print body & footer for selected columns\n            printBody(doc, table, startPos, cursor, colsAndIndexes.columns);\n            printFoot(doc, table, cursor, colsAndIndexes.columns);\n        });\n    } else {\n        var lastRowIndexOfLastPage_1 = -1;\n        var firstColumnsToFitResult = allColumnsCanFitResult[0];\n        var _loop_1 = function() {\n            // Print the first columns, taking note of the last row printed\n            var lastPrintedRowIndex = lastRowIndexOfLastPage_1;\n            if (firstColumnsToFitResult) {\n                doc.applyStyles(doc.userStyles);\n                var firstColumnsToFit = firstColumnsToFitResult.columns;\n                if (lastRowIndexOfLastPage_1 >= 0) {\n                    // When adding a page here, make sure not to print the footers\n                    // because they were already printed before on this same loop\n                    addPage(doc, table, startPos, cursor, firstColumnsToFit, true);\n                } else {\n                    printHead(doc, table, cursor, firstColumnsToFit);\n                }\n                lastPrintedRowIndex = printBodyWithoutPageBreaks(doc, table, lastRowIndexOfLastPage_1 + 1, cursor, firstColumnsToFit);\n                printFoot(doc, table, cursor, firstColumnsToFit);\n            }\n            // Check how many rows were printed, so that the next columns would not print more rows than that\n            var maxNumberOfRows = lastPrintedRowIndex - lastRowIndexOfLastPage_1;\n            // Print the next columns, never exceding maxNumberOfRows\n            allColumnsCanFitResult.slice(1).forEach(function(colsAndIndexes) {\n                doc.applyStyles(doc.userStyles);\n                // When adding a page here, make sure not to print the footers\n                // because they were already printed before on this same loop\n                addPage(doc, table, startPos, cursor, colsAndIndexes.columns, true);\n                printBodyWithoutPageBreaks(doc, table, lastRowIndexOfLastPage_1 + 1, cursor, colsAndIndexes.columns, maxNumberOfRows);\n                printFoot(doc, table, cursor, colsAndIndexes.columns);\n            });\n            lastRowIndexOfLastPage_1 = lastPrintedRowIndex;\n        };\n        while(lastRowIndexOfLastPage_1 < table.body.length - 1){\n            _loop_1();\n        }\n    }\n}\nfunction printHead(doc, table, cursor, columns) {\n    var settings = table.settings;\n    doc.applyStyles(doc.userStyles);\n    if (settings.showHead === \"firstPage\" || settings.showHead === \"everyPage\") {\n        table.head.forEach(function(row) {\n            return printRow(doc, table, row, cursor, columns);\n        });\n    }\n}\nfunction printBody(doc, table, startPos, cursor, columns) {\n    doc.applyStyles(doc.userStyles);\n    table.body.forEach(function(row, index) {\n        var isLastRow = index === table.body.length - 1;\n        printFullRow(doc, table, row, isLastRow, startPos, cursor, columns);\n    });\n}\nfunction printBodyWithoutPageBreaks(doc, table, startRowIndex, cursor, columns, maxNumberOfRows) {\n    doc.applyStyles(doc.userStyles);\n    maxNumberOfRows = maxNumberOfRows !== null && maxNumberOfRows !== void 0 ? maxNumberOfRows : table.body.length;\n    var endRowIndex = Math.min(startRowIndex + maxNumberOfRows, table.body.length);\n    var lastPrintedRowIndex = -1;\n    table.body.slice(startRowIndex, endRowIndex).forEach(function(row, index) {\n        var isLastRow = startRowIndex + index === table.body.length - 1;\n        var remainingSpace = getRemainingPageSpace(doc, table, isLastRow, cursor);\n        if (row.canEntireRowFit(remainingSpace, columns)) {\n            printRow(doc, table, row, cursor, columns);\n            lastPrintedRowIndex = startRowIndex + index;\n        }\n    });\n    return lastPrintedRowIndex;\n}\nfunction printFoot(doc, table, cursor, columns) {\n    var settings = table.settings;\n    doc.applyStyles(doc.userStyles);\n    if (settings.showFoot === \"lastPage\" || settings.showFoot === \"everyPage\") {\n        table.foot.forEach(function(row) {\n            return printRow(doc, table, row, cursor, columns);\n        });\n    }\n}\nfunction getRemainingLineCount(cell, remainingPageSpace, doc) {\n    var lineHeight = doc.getLineHeight(cell.styles.fontSize);\n    var vPadding = cell.padding(\"vertical\");\n    var remainingLines = Math.floor((remainingPageSpace - vPadding) / lineHeight);\n    return Math.max(0, remainingLines);\n}\nfunction modifyRowToFit(row, remainingPageSpace, table, doc) {\n    var cells = {};\n    row.spansMultiplePages = true;\n    row.height = 0;\n    var rowHeight = 0;\n    for(var _i = 0, _a = table.columns; _i < _a.length; _i++){\n        var column = _a[_i];\n        var cell = row.cells[column.index];\n        if (!cell) continue;\n        if (!Array.isArray(cell.text)) {\n            cell.text = [\n                cell.text\n            ];\n        }\n        var remainderCell = new Cell(cell.raw, cell.styles, cell.section);\n        remainderCell = assign(remainderCell, cell);\n        remainderCell.text = [];\n        var remainingLineCount = getRemainingLineCount(cell, remainingPageSpace, doc);\n        if (cell.text.length > remainingLineCount) {\n            remainderCell.text = cell.text.splice(remainingLineCount, cell.text.length);\n        }\n        var scaleFactor = doc.scaleFactor();\n        var lineHeightFactor = doc.getLineHeightFactor();\n        cell.contentHeight = cell.getContentHeight(scaleFactor, lineHeightFactor);\n        if (cell.contentHeight >= remainingPageSpace) {\n            cell.contentHeight = remainingPageSpace;\n            remainderCell.styles.minCellHeight -= remainingPageSpace;\n        }\n        if (cell.contentHeight > row.height) {\n            row.height = cell.contentHeight;\n        }\n        remainderCell.contentHeight = remainderCell.getContentHeight(scaleFactor, lineHeightFactor);\n        if (remainderCell.contentHeight > rowHeight) {\n            rowHeight = remainderCell.contentHeight;\n        }\n        cells[column.index] = remainderCell;\n    }\n    var remainderRow = new Row(row.raw, -1, row.section, cells, true);\n    remainderRow.height = rowHeight;\n    for(var _b = 0, _c = table.columns; _b < _c.length; _b++){\n        var column = _c[_b];\n        var remainderCell = remainderRow.cells[column.index];\n        if (remainderCell) {\n            remainderCell.height = remainderRow.height;\n        }\n        var cell = row.cells[column.index];\n        if (cell) {\n            cell.height = row.height;\n        }\n    }\n    return remainderRow;\n}\nfunction shouldPrintOnCurrentPage(doc, row, remainingPageSpace, table) {\n    var pageHeight = doc.pageSize().height;\n    var margin = table.settings.margin;\n    var marginHeight = margin.top + margin.bottom;\n    var maxRowHeight = pageHeight - marginHeight;\n    if (row.section === \"body\") {\n        // Should also take into account that head and foot is not\n        // on every page with some settings\n        maxRowHeight -= table.getHeadHeight(table.columns) + table.getFootHeight(table.columns);\n    }\n    var minRowHeight = row.getMinimumRowHeight(table.columns, doc);\n    var minRowFits = minRowHeight < remainingPageSpace;\n    if (minRowHeight > maxRowHeight) {\n        console.error(\"Will not be able to print row \".concat(row.index, \" correctly since it's minimum height is larger than page height\"));\n        return true;\n    }\n    if (!minRowFits) {\n        return false;\n    }\n    var rowHasRowSpanCell = row.hasRowSpan(table.columns);\n    var rowHigherThanPage = row.getMaxCellHeight(table.columns) > maxRowHeight;\n    if (rowHigherThanPage) {\n        if (rowHasRowSpanCell) {\n            console.error(\"The content of row \".concat(row.index, \" will not be drawn correctly since drawing rows with a height larger than the page height and has cells with rowspans is not supported.\"));\n        }\n        return true;\n    }\n    if (rowHasRowSpanCell) {\n        // Currently a new page is required whenever a rowspan row don't fit a page.\n        return false;\n    }\n    if (table.settings.rowPageBreak === \"avoid\") {\n        return false;\n    }\n    // In all other cases print the row on current page\n    return true;\n}\nfunction printFullRow(doc, table, row, isLastRow, startPos, cursor, columns) {\n    var remainingSpace = getRemainingPageSpace(doc, table, isLastRow, cursor);\n    if (row.canEntireRowFit(remainingSpace, columns)) {\n        // The row fits in the current page\n        printRow(doc, table, row, cursor, columns);\n    } else if (shouldPrintOnCurrentPage(doc, row, remainingSpace, table)) {\n        // The row gets split in two here, each piece in one page\n        var remainderRow = modifyRowToFit(row, remainingSpace, table, doc);\n        printRow(doc, table, row, cursor, columns);\n        addPage(doc, table, startPos, cursor, columns);\n        printFullRow(doc, table, remainderRow, isLastRow, startPos, cursor, columns);\n    } else {\n        // The row get printed entirelly on the next page\n        addPage(doc, table, startPos, cursor, columns);\n        printFullRow(doc, table, row, isLastRow, startPos, cursor, columns);\n    }\n}\nfunction printRow(doc, table, row, cursor, columns) {\n    cursor.x = table.settings.margin.left;\n    for(var _i = 0, columns_1 = columns; _i < columns_1.length; _i++){\n        var column = columns_1[_i];\n        var cell = row.cells[column.index];\n        if (!cell) {\n            cursor.x += column.width;\n            continue;\n        }\n        doc.applyStyles(cell.styles);\n        cell.x = cursor.x;\n        cell.y = cursor.y;\n        var result = table.callCellHooks(doc, table.hooks.willDrawCell, cell, row, column, cursor);\n        if (result === false) {\n            cursor.x += column.width;\n            continue;\n        }\n        drawCellRect(doc, cell, cursor);\n        var textPos = cell.getTextPos();\n        autoTableText(cell.text, textPos.x, textPos.y, {\n            halign: cell.styles.halign,\n            valign: cell.styles.valign,\n            maxWidth: Math.ceil(cell.width - cell.padding(\"left\") - cell.padding(\"right\"))\n        }, doc.getDocument());\n        table.callCellHooks(doc, table.hooks.didDrawCell, cell, row, column, cursor);\n        cursor.x += column.width;\n    }\n    cursor.y += row.height;\n}\nfunction drawCellRect(doc, cell, cursor) {\n    var cellStyles = cell.styles;\n    // https://github.com/simonbengtsson/jsPDF-AutoTable/issues/774\n    // TODO (v4): better solution?\n    doc.getDocument().setFillColor(doc.getDocument().getFillColor());\n    if (typeof cellStyles.lineWidth === \"number\") {\n        // Draw cell background with normal borders\n        var fillStyle = getFillStyle(cellStyles.lineWidth, cellStyles.fillColor);\n        if (fillStyle) {\n            doc.rect(cell.x, cursor.y, cell.width, cell.height, fillStyle);\n        }\n    } else if (typeof cellStyles.lineWidth === \"object\") {\n        // Draw cell background\n        if (cellStyles.fillColor) {\n            doc.rect(cell.x, cursor.y, cell.width, cell.height, \"F\");\n        }\n        // Draw cell individual borders\n        drawCellBorders(doc, cell, cursor, cellStyles.lineWidth);\n    }\n}\n/**\n * Draw all specified borders. Borders are centered on cell's edge and lengthened\n * to overlap with neighbours to create sharp corners.\n * @param doc\n * @param cell\n * @param cursor\n * @param fillColor\n * @param lineWidth\n */ function drawCellBorders(doc, cell, cursor, lineWidth) {\n    var x1, y1, x2, y2;\n    if (lineWidth.top) {\n        x1 = cursor.x;\n        y1 = cursor.y;\n        x2 = cursor.x + cell.width;\n        y2 = cursor.y;\n        if (lineWidth.right) {\n            x2 += 0.5 * lineWidth.right;\n        }\n        if (lineWidth.left) {\n            x1 -= 0.5 * lineWidth.left;\n        }\n        drawLine(lineWidth.top, x1, y1, x2, y2);\n    }\n    if (lineWidth.bottom) {\n        x1 = cursor.x;\n        y1 = cursor.y + cell.height;\n        x2 = cursor.x + cell.width;\n        y2 = cursor.y + cell.height;\n        if (lineWidth.right) {\n            x2 += 0.5 * lineWidth.right;\n        }\n        if (lineWidth.left) {\n            x1 -= 0.5 * lineWidth.left;\n        }\n        drawLine(lineWidth.bottom, x1, y1, x2, y2);\n    }\n    if (lineWidth.left) {\n        x1 = cursor.x;\n        y1 = cursor.y;\n        x2 = cursor.x;\n        y2 = cursor.y + cell.height;\n        if (lineWidth.top) {\n            y1 -= 0.5 * lineWidth.top;\n        }\n        if (lineWidth.bottom) {\n            y2 += 0.5 * lineWidth.bottom;\n        }\n        drawLine(lineWidth.left, x1, y1, x2, y2);\n    }\n    if (lineWidth.right) {\n        x1 = cursor.x + cell.width;\n        y1 = cursor.y;\n        x2 = cursor.x + cell.width;\n        y2 = cursor.y + cell.height;\n        if (lineWidth.top) {\n            y1 -= 0.5 * lineWidth.top;\n        }\n        if (lineWidth.bottom) {\n            y2 += 0.5 * lineWidth.bottom;\n        }\n        drawLine(lineWidth.right, x1, y1, x2, y2);\n    }\n    function drawLine(width, x1, y1, x2, y2) {\n        doc.getDocument().setLineWidth(width);\n        doc.getDocument().line(x1, y1, x2, y2, \"S\");\n    }\n}\nfunction getRemainingPageSpace(doc, table, isLastRow, cursor) {\n    var bottomContentHeight = table.settings.margin.bottom;\n    var showFoot = table.settings.showFoot;\n    if (showFoot === \"everyPage\" || showFoot === \"lastPage\" && isLastRow) {\n        bottomContentHeight += table.getFootHeight(table.columns);\n    }\n    return doc.pageSize().height - cursor.y - bottomContentHeight;\n}\nfunction addPage(doc, table, startPos, cursor, columns, suppressFooter) {\n    if (columns === void 0) {\n        columns = [];\n    }\n    if (suppressFooter === void 0) {\n        suppressFooter = false;\n    }\n    doc.applyStyles(doc.userStyles);\n    if (table.settings.showFoot === \"everyPage\" && !suppressFooter) {\n        table.foot.forEach(function(row) {\n            return printRow(doc, table, row, cursor, columns);\n        });\n    }\n    // Add user content just before adding new page ensure it will\n    // be drawn above other things on the page\n    table.callEndPageHooks(doc, cursor);\n    var margin = table.settings.margin;\n    addTableBorder(doc, table, startPos, cursor);\n    nextPage(doc);\n    table.pageNumber++;\n    cursor.x = margin.left;\n    cursor.y = margin.top;\n    startPos.y = margin.top;\n    // call didAddPage hooks before any content is added to the page\n    table.callWillDrawPageHooks(doc, cursor);\n    if (table.settings.showHead === \"everyPage\") {\n        table.head.forEach(function(row) {\n            return printRow(doc, table, row, cursor, columns);\n        });\n        doc.applyStyles(doc.userStyles);\n    }\n}\nfunction nextPage(doc) {\n    var current = doc.pageNumber();\n    doc.setPage(current + 1);\n    var newCurrent = doc.pageNumber();\n    if (newCurrent === current) {\n        doc.addPage();\n        return true;\n    }\n    return false;\n}\nfunction applyPlugin(jsPDF) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    jsPDF.API.autoTable = function() {\n        var args = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            args[_i] = arguments[_i];\n        }\n        var options = args[0];\n        var input = parseInput(this, options);\n        var table = createTable(this, input);\n        drawTable(this, table);\n        return this;\n    };\n    // Assign false to enable `doc.lastAutoTable.finalY || 40` sugar\n    jsPDF.API.lastAutoTable = false;\n    jsPDF.API.autoTableText = function(text, x, y, styles) {\n        autoTableText(text, x, y, styles, this);\n    };\n    jsPDF.API.autoTableSetDefaults = function(defaults) {\n        DocHandler.setDefaults(defaults, this);\n        return this;\n    };\n    jsPDF.autoTableSetDefaults = function(defaults, doc) {\n        DocHandler.setDefaults(defaults, doc);\n    };\n    jsPDF.API.autoTableHtmlToJson = function(tableElem, includeHiddenElements) {\n        var _a;\n        if (includeHiddenElements === void 0) {\n            includeHiddenElements = false;\n        }\n        if (true) {\n            console.error(\"Cannot run autoTableHtmlToJson in non browser environment\");\n            return null;\n        }\n        var doc = new DocHandler(this);\n        var _b = parseHtml(doc, tableElem, window, includeHiddenElements, false), head = _b.head, body = _b.body;\n        var columns = ((_a = head[0]) === null || _a === void 0 ? void 0 : _a.map(function(c) {\n            return c.content;\n        })) || [];\n        return {\n            columns: columns,\n            rows: body,\n            data: body\n        };\n    };\n}\nvar _a;\nfunction autoTable(d, options) {\n    var input = parseInput(d, options);\n    var table = createTable(d, input);\n    drawTable(d, table);\n}\n// Experimental export\nfunction __createTable(d, options) {\n    var input = parseInput(d, options);\n    return createTable(d, input);\n}\nfunction __drawTable(d, table) {\n    drawTable(d, table);\n}\ntry {\n    if (false) { var jsPDF, anyWindow; }\n} catch (error) {\n    console.error(\"Could not apply autoTable plugin\", error);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvanNwZGYtYXV0b3RhYmxlL2Rpc3QvanNwZGYucGx1Z2luLmF1dG90YWJsZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDRCxTQUFTQSxjQUFlQyxJQUFJLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxNQUFNLEVBQUVDLEdBQUc7SUFDM0NELFNBQVNBLFVBQVUsQ0FBQztJQUNwQixJQUFJRSx1QkFBdUI7SUFDM0IsSUFBSUMsSUFBSUYsSUFBSUcsUUFBUSxDQUFDQyxXQUFXO0lBQ2hDLElBQUlDLFdBQVdMLElBQUlHLFFBQVEsQ0FBQ0csV0FBVyxLQUFLSjtJQUM1QyxJQUFJSyxtQkFBbUJQLElBQUlRLG1CQUFtQixHQUN4Q1IsSUFBSVEsbUJBQW1CLEtBQ3ZCUDtJQUNOLElBQUlRLGFBQWFKLFdBQVdFO0lBQzVCLElBQUlHLGFBQWE7SUFDakIsSUFBSUMsWUFBWTtJQUNoQixJQUFJQyxZQUFZO0lBQ2hCLElBQUliLE9BQU9jLE1BQU0sS0FBSyxZQUNsQmQsT0FBT2MsTUFBTSxLQUFLLFlBQ2xCZCxPQUFPZSxNQUFNLEtBQUssWUFDbEJmLE9BQU9lLE1BQU0sS0FBSyxTQUFTO1FBQzNCSCxZQUFZLE9BQU9mLFNBQVMsV0FBV0EsS0FBS21CLEtBQUssQ0FBQ0wsY0FBY2Q7UUFDaEVnQixZQUFZRCxVQUFVSyxNQUFNLElBQUk7SUFDcEM7SUFDQSxnQkFBZ0I7SUFDaEJsQixLQUFLTyxXQUFZLEtBQUlKLG9CQUFtQjtJQUN4QyxJQUFJRixPQUFPYyxNQUFNLEtBQUssVUFDbEJmLEtBQUssWUFBYSxJQUFLVztTQUN0QixJQUFJVixPQUFPYyxNQUFNLEtBQUssVUFDdkJmLEtBQUtjLFlBQVlIO0lBQ3JCLElBQUlWLE9BQU9lLE1BQU0sS0FBSyxZQUFZZixPQUFPZSxNQUFNLEtBQUssU0FBUztRQUN6RCxJQUFJRyxZQUFZWjtRQUNoQixJQUFJTixPQUFPZSxNQUFNLEtBQUssVUFDbEJHLGFB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U0FBVTdGLENBQUM7WUFBSSxPQUFPQSxFQUFFK0wsT0FBTztRQUFFLEVBQUMsS0FBTSxFQUFFO1FBQ3BILE9BQU87WUFBRXNGLFNBQVNBO1lBQVNwRyxNQUFNNUY7WUFBTXVOLE1BQU12TjtRQUFLO0lBQ3REO0FBQ0o7QUFFQSxJQUFJL0U7QUFDSixTQUFTb2QsVUFBVTFhLENBQUMsRUFBRThKLE9BQU87SUFDekIsSUFBSXRDLFFBQVFtRCxXQUFXM0ssR0FBRzhKO0lBQzFCLElBQUkzSCxRQUFRNlIsWUFBWWhVLEdBQUd3SDtJQUMzQnVQLFVBQVUvVyxHQUFHbUM7QUFDakI7QUFDQSxzQkFBc0I7QUFDdEIsU0FBUzZZLGNBQWNoYixDQUFDLEVBQUU4SixPQUFPO0lBQzdCLElBQUl0QyxRQUFRbUQsV0FBVzNLLEdBQUc4SjtJQUMxQixPQUFPa0ssWUFBWWhVLEdBQUd3SDtBQUMxQjtBQUNBLFNBQVN5VCxZQUFZamIsQ0FBQyxFQUFFbUMsS0FBSztJQUN6QjRVLFVBQVUvVyxHQUFHbUM7QUFDakI7QUFDQSxJQUFJO0lBQ0EsSUFBSSxLQUF1Q3VDLEVBQUUseUJBTzVDO0FBQ0wsRUFDQSxPQUFPM0QsT0FBTztJQUNWZ0gsUUFBUWhILEtBQUssQ0FBQyxvQ0FBb0NBO0FBQ3REO0FBRXNJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLXJlZ2lzdHJvLWFwcC8uL25vZGVfbW9kdWxlcy9qc3BkZi1hdXRvdGFibGUvZGlzdC9qc3BkZi5wbHVnaW4uYXV0b3RhYmxlLm1qcz9hYWY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW1wcm92ZWQgdGV4dCBmdW5jdGlvbiB3aXRoIGhhbGlnbiBhbmQgdmFsaWduIHN1cHBvcnRcbiAqIEluc3BpcmF0aW9uIGZyb206IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjgzMjc1MTAvYWxpZ24tdGV4dC1yaWdodC11c2luZy1qc3BkZi8yODQzMzExMyMyODQzMzExM1xuICovXG5mdW5jdGlvbiBhdXRvVGFibGVUZXh0ICh0ZXh0LCB4LCB5LCBzdHlsZXMsIGRvYykge1xuICAgIHN0eWxlcyA9IHN0eWxlcyB8fCB7fTtcbiAgICB2YXIgUEhZU0lDQUxfTElORV9IRUlHSFQgPSAxLjE1O1xuICAgIHZhciBrID0gZG9jLmludGVybmFsLnNjYWxlRmFjdG9yO1xuICAgIHZhciBmb250U2l6ZSA9IGRvYy5pbnRlcm5hbC5nZXRGb250U2l6ZSgpIC8gaztcbiAgICB2YXIgbGluZUhlaWdodEZhY3RvciA9IGRvYy5nZXRMaW5lSGVpZ2h0RmFjdG9yXG4gICAgICAgID8gZG9jLmdldExpbmVIZWlnaHRGYWN0b3IoKVxuICAgICAgICA6IFBIWVNJQ0FMX0xJTkVfSEVJR0hUO1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gZm9udFNpemUgKiBsaW5lSGVpZ2h0RmFjdG9yO1xuICAgIHZhciBzcGxpdFJlZ2V4ID0gL1xcclxcbnxcXHJ8XFxuL2c7XG4gICAgdmFyIHNwbGl0VGV4dCA9ICcnO1xuICAgIHZhciBsaW5lQ291bnQgPSAxO1xuICAgIGlmIChzdHlsZXMudmFsaWduID09PSAnbWlkZGxlJyB8fFxuICAgICAgICBzdHlsZXMudmFsaWduID09PSAnYm90dG9tJyB8fFxuICAgICAgICBzdHlsZXMuaGFsaWduID09PSAnY2VudGVyJyB8fFxuICAgICAgICBzdHlsZXMuaGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHNwbGl0VGV4dCA9IHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJyA/IHRleHQuc3BsaXQoc3BsaXRSZWdleCkgOiB0ZXh0O1xuICAgICAgICBsaW5lQ291bnQgPSBzcGxpdFRleHQubGVuZ3RoIHx8IDE7XG4gICAgfVxuICAgIC8vIEFsaWduIHRoZSB0b3BcbiAgICB5ICs9IGZvbnRTaXplICogKDIgLSBQSFlTSUNBTF9MSU5FX0hFSUdIVCk7XG4gICAgaWYgKHN0eWxlcy52YWxpZ24gPT09ICdtaWRkbGUnKVxuICAgICAgICB5IC09IChsaW5lQ291bnQgLyAyKSAqIGxpbmVIZWlnaHQ7XG4gICAgZWxzZSBpZiAoc3R5bGVzLnZhbGlnbiA9PT0gJ2JvdHRvbScpXG4gICAgICAgIHkgLT0gbGluZUNvdW50ICogbGluZUhlaWdodDtcbiAgICBpZiAoc3R5bGVzLmhhbGlnbiA9PT0gJ2NlbnRlcicgfHwgc3R5bGVzLmhhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB2YXIgYWxpZ25TaXplID0gZm9udFNpemU7XG4gICAgICAgIGlmIChzdHlsZXMuaGFsaWduID09PSAnY2VudGVyJylcbiAgICAgICAgICAgIGFsaWduU2l6ZSAqPSAwLjU7XG4gICAgICAgIGlmIChzcGxpdFRleHQgJiYgbGluZUNvdW50ID49IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlMaW5lID0gMDsgaUxpbmUgPCBzcGxpdFRleHQubGVuZ3RoOyBpTGluZSsrKSB7XG4gICAgICAgICAgICAgICAgZG9jLnRleHQoc3BsaXRUZXh0W2lMaW5lXSwgeCAtIGRvYy5nZXRTdHJpbmdVbml0V2lkdGgoc3BsaXRUZXh0W2lMaW5lXSkgKiBhbGlnblNpemUsIHkpO1xuICAgICAgICAgICAgICAgIHkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgIH1cbiAgICAgICAgeCAtPSBkb2MuZ2V0U3RyaW5nVW5pdFdpZHRoKHRleHQpICogYWxpZ25TaXplO1xuICAgIH1cbiAgICBpZiAoc3R5bGVzLmhhbGlnbiA9PT0gJ2p1c3RpZnknKSB7XG4gICAgICAgIGRvYy50ZXh0KHRleHQsIHgsIHksIHsgbWF4V2lkdGg6IHN0eWxlcy5tYXhXaWR0aCB8fCAxMDAsIGFsaWduOiAnanVzdGlmeScgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkb2MudGV4dCh0ZXh0LCB4LCB5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRvYztcbn1cblxudmFyIGdsb2JhbERlZmF1bHRzID0ge307XG52YXIgRG9jSGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb2NIYW5kbGVyKGpzUERGRG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5qc1BERkRvY3VtZW50ID0ganNQREZEb2N1bWVudDtcbiAgICAgICAgdGhpcy51c2VyU3R5bGVzID0ge1xuICAgICAgICAgICAgLy8gQmxhY2sgZm9yIHZlcnNpb25zIG9mIGpzcGRmIHdpdGhvdXQgZ2V0VGV4dENvbG9yXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IGpzUERGRG9jdW1lbnQuZ2V0VGV4dENvbG9yXG4gICAgICAgICAgICAgICAgPyB0aGlzLmpzUERGRG9jdW1lbnQuZ2V0VGV4dENvbG9yKClcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBmb250U2l6ZToganNQREZEb2N1bWVudC5pbnRlcm5hbC5nZXRGb250U2l6ZSgpLFxuICAgICAgICAgICAgZm9udFN0eWxlOiBqc1BERkRvY3VtZW50LmludGVybmFsLmdldEZvbnQoKS5mb250U3R5bGUsXG4gICAgICAgICAgICBmb250OiBqc1BERkRvY3VtZW50LmludGVybmFsLmdldEZvbnQoKS5mb250TmFtZSxcbiAgICAgICAgICAgIC8vIDAgZm9yIHZlcnNpb25zIG9mIGpzcGRmIHdpdGhvdXQgZ2V0TGluZVdpZHRoXG4gICAgICAgICAgICBsaW5lV2lkdGg6IGpzUERGRG9jdW1lbnQuZ2V0TGluZVdpZHRoXG4gICAgICAgICAgICAgICAgPyB0aGlzLmpzUERGRG9jdW1lbnQuZ2V0TGluZVdpZHRoKClcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICAvLyBCbGFjayBmb3IgdmVyc2lvbnMgb2YganNwZGYgd2l0aG91dCBnZXREcmF3Q29sb3JcbiAgICAgICAgICAgIGxpbmVDb2xvcjoganNQREZEb2N1bWVudC5nZXREcmF3Q29sb3JcbiAgICAgICAgICAgICAgICA/IHRoaXMuanNQREZEb2N1bWVudC5nZXREcmF3Q29sb3IoKVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRG9jSGFuZGxlci5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIChkZWZhdWx0cywgZG9jKSB7XG4gICAgICAgIGlmIChkb2MgPT09IHZvaWQgMCkgeyBkb2MgPSBudWxsOyB9XG4gICAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgICAgIGRvYy5fX2F1dG9UYWJsZURvY3VtZW50RGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbERlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvY0hhbmRsZXIudW5pZnlDb2xvciA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBbYywgYywgY107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvY0hhbmRsZXIucHJvdG90eXBlLmFwcGx5U3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcywgZm9udE9ubHkpIHtcbiAgICAgICAgLy8gRm9udCBzdHlsZSBuZWVkcyB0byBiZSBhcHBsaWVkIGJlZm9yZSBmb250XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW1vbmJlbmd0c3Nvbi9qc1BERi1BdXRvVGFibGUvaXNzdWVzLzYzMlxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKGZvbnRPbmx5ID09PSB2b2lkIDApIHsgZm9udE9ubHkgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoc3R5bGVzLmZvbnRTdHlsZSAmJiB0aGlzLmpzUERGRG9jdW1lbnQuc2V0Rm9udFN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLmpzUERGRG9jdW1lbnQuc2V0Rm9udFN0eWxlKHN0eWxlcy5mb250U3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfZCA9IHRoaXMuanNQREZEb2N1bWVudC5pbnRlcm5hbC5nZXRGb250KCksIGZvbnRTdHlsZSA9IF9kLmZvbnRTdHlsZSwgZm9udE5hbWUgPSBfZC5mb250TmFtZTtcbiAgICAgICAgaWYgKHN0eWxlcy5mb250KVxuICAgICAgICAgICAgZm9udE5hbWUgPSBzdHlsZXMuZm9udDtcbiAgICAgICAgaWYgKHN0eWxlcy5mb250U3R5bGUpIHtcbiAgICAgICAgICAgIGZvbnRTdHlsZSA9IHN0eWxlcy5mb250U3R5bGU7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlRm9udFN0eWxlcyA9IHRoaXMuZ2V0Rm9udExpc3QoKVtmb250TmFtZV07XG4gICAgICAgICAgICBpZiAoYXZhaWxhYmxlRm9udFN0eWxlcyAmJlxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUZvbnRTdHlsZXMuaW5kZXhPZihmb250U3R5bGUpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuanNQREZEb2N1bWVudC5zZXRGb250U3R5bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDb21tb24gaXNzdWUgd2FzIHRoYXQgdGhlIGRlZmF1bHQgYm9sZCBpbiBoZWFkZXJzXG4gICAgICAgICAgICAgICAgLy8gbWFkZSBjdXN0b20gZm9udHMgbm90IHdvcmsuIEZvciBleGFtcGxlOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW1vbmJlbmd0c3Nvbi9qc1BERi1BdXRvVGFibGUvaXNzdWVzLzY1M1xuICAgICAgICAgICAgICAgIHRoaXMuanNQREZEb2N1bWVudC5zZXRGb250U3R5bGUoYXZhaWxhYmxlRm9udFN0eWxlc1swXSk7XG4gICAgICAgICAgICAgICAgZm9udFN0eWxlID0gYXZhaWxhYmxlRm9udFN0eWxlc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmpzUERGRG9jdW1lbnQuc2V0Rm9udChmb250TmFtZSwgZm9udFN0eWxlKTtcbiAgICAgICAgaWYgKHN0eWxlcy5mb250U2l6ZSlcbiAgICAgICAgICAgIHRoaXMuanNQREZEb2N1bWVudC5zZXRGb250U2l6ZShzdHlsZXMuZm9udFNpemUpO1xuICAgICAgICBpZiAoZm9udE9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gUGVyZm9ybWFuY2UgaW1wcm92ZW1lbnRcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sb3IgPSBEb2NIYW5kbGVyLnVuaWZ5Q29sb3Ioc3R5bGVzLmZpbGxDb2xvcik7XG4gICAgICAgIGlmIChjb2xvcilcbiAgICAgICAgICAgIChfYSA9IHRoaXMuanNQREZEb2N1bWVudCkuc2V0RmlsbENvbG9yLmFwcGx5KF9hLCBjb2xvcik7XG4gICAgICAgIGNvbG9yID0gRG9jSGFuZGxlci51bmlmeUNvbG9yKHN0eWxlcy50ZXh0Q29sb3IpO1xuICAgICAgICBpZiAoY29sb3IpXG4gICAgICAgICAgICAoX2IgPSB0aGlzLmpzUERGRG9jdW1lbnQpLnNldFRleHRDb2xvci5hcHBseShfYiwgY29sb3IpO1xuICAgICAgICBjb2xvciA9IERvY0hhbmRsZXIudW5pZnlDb2xvcihzdHlsZXMubGluZUNvbG9yKTtcbiAgICAgICAgaWYgKGNvbG9yKVxuICAgICAgICAgICAgKF9jID0gdGhpcy5qc1BERkRvY3VtZW50KS5zZXREcmF3Q29sb3IuYXBwbHkoX2MsIGNvbG9yKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZXMubGluZVdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5qc1BERkRvY3VtZW50LnNldExpbmVXaWR0aChzdHlsZXMubGluZVdpZHRoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9jSGFuZGxlci5wcm90b3R5cGUuc3BsaXRUZXh0VG9TaXplID0gZnVuY3Rpb24gKHRleHQsIHNpemUsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNQREZEb2N1bWVudC5zcGxpdFRleHRUb1NpemUodGV4dCwgc2l6ZSwgb3B0cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcmVjdGFuZ2xlIHRvIHRoZSBQREZcbiAgICAgKiBAcGFyYW0geCBDb29yZGluYXRlIChpbiB1bml0cyBkZWNsYXJlZCBhdCBpbmNlcHRpb24gb2YgUERGIGRvY3VtZW50KSBhZ2FpbnN0IGxlZnQgZWRnZSBvZiB0aGUgcGFnZVxuICAgICAqIEBwYXJhbSB5IENvb3JkaW5hdGUgKGluIHVuaXRzIGRlY2xhcmVkIGF0IGluY2VwdGlvbiBvZiBQREYgZG9jdW1lbnQpIGFnYWluc3QgdXBwZXIgZWRnZSBvZiB0aGUgcGFnZVxuICAgICAqIEBwYXJhbSB3aWR0aCBXaWR0aCAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudClcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IEhlaWdodCAoaW4gdW5pdHMgZGVjbGFyZWQgYXQgaW5jZXB0aW9uIG9mIFBERiBkb2N1bWVudClcbiAgICAgKiBAcGFyYW0gZmlsbFN0eWxlIEEgc3RyaW5nIHNwZWNpZnlpbmcgdGhlIHBhaW50aW5nIHN0eWxlIG9yIG51bGwuIFZhbGlkIHN0eWxlcyBpbmNsdWRlOiAnUycgW2RlZmF1bHRdIC0gc3Ryb2tlLCAnRicgLSBmaWxsLCBhbmQgJ0RGJyAob3IgJ0ZEJykgLSBmaWxsIHRoZW4gc3Ryb2tlLlxuICAgICAqL1xuICAgIERvY0hhbmRsZXIucHJvdG90eXBlLnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgZmlsbFN0eWxlKSB7XG4gICAgICAgIC8vIG51bGwgaXMgZXhjbHVkZWQgZnJvbSBmaWxsU3R5bGUgcG9zc2libGUgdmFsdWVzIGJlY2F1c2UgaXQgaXNuJ3QgbmVlZGVkXG4gICAgICAgIC8vIGFuZCBpcyBwcm9uZSB0byBidWdzIGFzIGl0J3MgdXNlZCB0byBwb3N0cG9uZSBzZXR0aW5nIHRoZSBzdHlsZVxuICAgICAgICAvLyBodHRwczovL3Jhd2dpdC5jb20vTXJSaW8vanNQREYvbWFzdGVyL2RvY3MvanNQREYuaHRtbCNyZWN0XG4gICAgICAgIHJldHVybiB0aGlzLmpzUERGRG9jdW1lbnQucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmaWxsU3R5bGUpO1xuICAgIH07XG4gICAgRG9jSGFuZGxlci5wcm90b3R5cGUuZ2V0TGFzdEF1dG9UYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNQREZEb2N1bWVudC5sYXN0QXV0b1RhYmxlIHx8IG51bGw7XG4gICAgfTtcbiAgICBEb2NIYW5kbGVyLnByb3RvdHlwZS5nZXRUZXh0V2lkdGggPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qc1BERkRvY3VtZW50LmdldFRleHRXaWR0aCh0ZXh0KTtcbiAgICB9O1xuICAgIERvY0hhbmRsZXIucHJvdG90eXBlLmdldERvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qc1BERkRvY3VtZW50O1xuICAgIH07XG4gICAgRG9jSGFuZGxlci5wcm90b3R5cGUuc2V0UGFnZSA9IGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgICAgIHRoaXMuanNQREZEb2N1bWVudC5zZXRQYWdlKHBhZ2UpO1xuICAgIH07XG4gICAgRG9jSGFuZGxlci5wcm90b3R5cGUuYWRkUGFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNQREZEb2N1bWVudC5hZGRQYWdlKCk7XG4gICAgfTtcbiAgICBEb2NIYW5kbGVyLnByb3RvdHlwZS5nZXRGb250TGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNQREZEb2N1bWVudC5nZXRGb250TGlzdCgpO1xuICAgIH07XG4gICAgRG9jSGFuZGxlci5wcm90b3R5cGUuZ2V0R2xvYmFsT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbERlZmF1bHRzIHx8IHt9O1xuICAgIH07XG4gICAgRG9jSGFuZGxlci5wcm90b3R5cGUuZ2V0RG9jdW1lbnRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qc1BERkRvY3VtZW50Ll9fYXV0b1RhYmxlRG9jdW1lbnREZWZhdWx0cyB8fCB7fTtcbiAgICB9O1xuICAgIERvY0hhbmRsZXIucHJvdG90eXBlLnBhZ2VTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFnZVNpemUgPSB0aGlzLmpzUERGRG9jdW1lbnQuaW50ZXJuYWwucGFnZVNpemU7XG4gICAgICAgIC8vIEpTUERGIDEuNCB1c2VzIGdldCBmdW5jdGlvbnMgaW5zdGVhZCBvZiBwcm9wZXJ0aWVzIG9uIHBhZ2VTaXplXG4gICAgICAgIGlmIChwYWdlU2l6ZS53aWR0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwYWdlU2l6ZSA9IHsgd2lkdGg6IHBhZ2VTaXplLmdldFdpZHRoKCksIGhlaWdodDogcGFnZVNpemUuZ2V0SGVpZ2h0KCkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFnZVNpemU7XG4gICAgfTtcbiAgICBEb2NIYW5kbGVyLnByb3RvdHlwZS5zY2FsZUZhY3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNQREZEb2N1bWVudC5pbnRlcm5hbC5zY2FsZUZhY3RvcjtcbiAgICB9O1xuICAgIERvY0hhbmRsZXIucHJvdG90eXBlLmdldExpbmVIZWlnaHRGYWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmpzUERGRG9jdW1lbnQ7XG4gICAgICAgIHJldHVybiBkb2MuZ2V0TGluZUhlaWdodEZhY3RvciA/IGRvYy5nZXRMaW5lSGVpZ2h0RmFjdG9yKCkgOiAxLjE1O1xuICAgIH07XG4gICAgRG9jSGFuZGxlci5wcm90b3R5cGUuZ2V0TGluZUhlaWdodCA9IGZ1bmN0aW9uIChmb250U2l6ZSkge1xuICAgICAgICByZXR1cm4gKGZvbnRTaXplIC8gdGhpcy5zY2FsZUZhY3RvcigpKSAqIHRoaXMuZ2V0TGluZUhlaWdodEZhY3RvcigpO1xuICAgIH07XG4gICAgRG9jSGFuZGxlci5wcm90b3R5cGUucGFnZU51bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhZ2VJbmZvID0gdGhpcy5qc1BERkRvY3VtZW50LmludGVybmFsLmdldEN1cnJlbnRQYWdlSW5mbygpO1xuICAgICAgICBpZiAoIXBhZ2VJbmZvKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHJlY2VudCB2ZXJzaW9ucyBvZiBqc3BkZiBoYXMgcGFnZUluZm9cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmpzUERGRG9jdW1lbnQuaW50ZXJuYWwuZ2V0TnVtYmVyT2ZQYWdlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWdlSW5mby5wYWdlTnVtYmVyO1xuICAgIH07XG4gICAgcmV0dXJuIERvY0hhbmRsZXI7XG59KCkpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbnZhciBIdG1sUm93SW5wdXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEh0bWxSb3dJbnB1dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIdG1sUm93SW5wdXQoZWxlbWVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEh0bWxSb3dJbnB1dDtcbn0oQXJyYXkpKTtcbi8vIEJhc2Ugc3R5bGUgZm9yIGFsbCB0aGVtZXNcbmZ1bmN0aW9uIGRlZmF1bHRTdHlsZXMoc2NhbGVGYWN0b3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb250OiAnaGVsdmV0aWNhJywgLy8gaGVsdmV0aWNhLCB0aW1lcywgY291cmllclxuICAgICAgICBmb250U3R5bGU6ICdub3JtYWwnLCAvLyBub3JtYWwsIGJvbGQsIGl0YWxpYywgYm9sZGl0YWxpY1xuICAgICAgICBvdmVyZmxvdzogJ2xpbmVicmVhaycsIC8vIGxpbmVicmVhaywgZWxsaXBzaXplLCB2aXNpYmxlIG9yIGhpZGRlblxuICAgICAgICBmaWxsQ29sb3I6IGZhbHNlLCAvLyBFaXRoZXIgZmFsc2UgZm9yIHRyYW5zcGFyZW50LCByYmcgYXJyYXkgZS5nLiBbMjU1LCAyNTUsIDI1NV0gb3IgZ3JheSBsZXZlbCBlLmcgMjAwXG4gICAgICAgIHRleHRDb2xvcjogMjAsXG4gICAgICAgIGhhbGlnbjogJ2xlZnQnLCAvLyBsZWZ0LCBjZW50ZXIsIHJpZ2h0LCBqdXN0aWZ5XG4gICAgICAgIHZhbGlnbjogJ3RvcCcsIC8vIHRvcCwgbWlkZGxlLCBib3R0b21cbiAgICAgICAgZm9udFNpemU6IDEwLFxuICAgICAgICBjZWxsUGFkZGluZzogNSAvIHNjYWxlRmFjdG9yLCAvLyBudW1iZXIgb3Ige3RvcCxsZWZ0LHJpZ2h0LGxlZnQsdmVydGljYWwsaG9yaXpvbnRhbH1cbiAgICAgICAgbGluZUNvbG9yOiAyMDAsXG4gICAgICAgIGxpbmVXaWR0aDogMCxcbiAgICAgICAgY2VsbFdpZHRoOiAnYXV0bycsIC8vICdhdXRvJ3wnd3JhcCd8bnVtYmVyXG4gICAgICAgIG1pbkNlbGxIZWlnaHQ6IDAsXG4gICAgICAgIG1pbkNlbGxXaWR0aDogMCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0VGhlbWUobmFtZSkge1xuICAgIHZhciB0aGVtZXMgPSB7XG4gICAgICAgIHN0cmlwZWQ6IHtcbiAgICAgICAgICAgIHRhYmxlOiB7IGZpbGxDb2xvcjogMjU1LCB0ZXh0Q29sb3I6IDgwLCBmb250U3R5bGU6ICdub3JtYWwnIH0sXG4gICAgICAgICAgICBoZWFkOiB7IHRleHRDb2xvcjogMjU1LCBmaWxsQ29sb3I6IFs0MSwgMTI4LCAxODVdLCBmb250U3R5bGU6ICdib2xkJyB9LFxuICAgICAgICAgICAgYm9keToge30sXG4gICAgICAgICAgICBmb290OiB7IHRleHRDb2xvcjogMjU1LCBmaWxsQ29sb3I6IFs0MSwgMTI4LCAxODVdLCBmb250U3R5bGU6ICdib2xkJyB9LFxuICAgICAgICAgICAgYWx0ZXJuYXRlUm93OiB7IGZpbGxDb2xvcjogMjQ1IH0sXG4gICAgICAgIH0sXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgIHRhYmxlOiB7XG4gICAgICAgICAgICAgICAgZmlsbENvbG9yOiAyNTUsXG4gICAgICAgICAgICAgICAgdGV4dENvbG9yOiA4MCxcbiAgICAgICAgICAgICAgICBmb250U3R5bGU6ICdub3JtYWwnLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMC4xLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlYWQ6IHtcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IDI1NSxcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IFsyNiwgMTg4LCAxNTZdLFxuICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogJ2JvbGQnLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiB7fSxcbiAgICAgICAgICAgIGZvb3Q6IHtcbiAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6IDI1NSxcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IFsyNiwgMTg4LCAxNTZdLFxuICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogJ2JvbGQnLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbHRlcm5hdGVSb3c6IHt9LFxuICAgICAgICB9LFxuICAgICAgICBwbGFpbjogeyBoZWFkOiB7IGZvbnRTdHlsZTogJ2JvbGQnIH0sIGZvb3Q6IHsgZm9udFN0eWxlOiAnYm9sZCcgfSB9LFxuICAgIH07XG4gICAgcmV0dXJuIHRoZW1lc1tuYW1lXTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyaW5nV2lkdGgodGV4dCwgc3R5bGVzLCBkb2MpIHtcbiAgICBkb2MuYXBwbHlTdHlsZXMoc3R5bGVzLCB0cnVlKTtcbiAgICB2YXIgdGV4dEFyciA9IEFycmF5LmlzQXJyYXkodGV4dCkgPyB0ZXh0IDogW3RleHRdO1xuICAgIHZhciB3aWRlc3RMaW5lV2lkdGggPSB0ZXh0QXJyXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHRleHQpIHsgcmV0dXJuIGRvYy5nZXRUZXh0V2lkdGgodGV4dCk7IH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIE1hdGgubWF4KGEsIGIpOyB9LCAwKTtcbiAgICByZXR1cm4gd2lkZXN0TGluZVdpZHRoO1xufVxuZnVuY3Rpb24gYWRkVGFibGVCb3JkZXIoZG9jLCB0YWJsZSwgc3RhcnRQb3MsIGN1cnNvcikge1xuICAgIHZhciBsaW5lV2lkdGggPSB0YWJsZS5zZXR0aW5ncy50YWJsZUxpbmVXaWR0aDtcbiAgICB2YXIgbGluZUNvbG9yID0gdGFibGUuc2V0dGluZ3MudGFibGVMaW5lQ29sb3I7XG4gICAgZG9jLmFwcGx5U3R5bGVzKHsgbGluZVdpZHRoOiBsaW5lV2lkdGgsIGxpbmVDb2xvcjogbGluZUNvbG9yIH0pO1xuICAgIHZhciBmaWxsU3R5bGUgPSBnZXRGaWxsU3R5bGUobGluZVdpZHRoLCBmYWxzZSk7XG4gICAgaWYgKGZpbGxTdHlsZSkge1xuICAgICAgICBkb2MucmVjdChzdGFydFBvcy54LCBzdGFydFBvcy55LCB0YWJsZS5nZXRXaWR0aChkb2MucGFnZVNpemUoKS53aWR0aCksIGN1cnNvci55IC0gc3RhcnRQb3MueSwgZmlsbFN0eWxlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRGaWxsU3R5bGUobGluZVdpZHRoLCBmaWxsQ29sb3IpIHtcbiAgICB2YXIgZHJhd0xpbmUgPSBsaW5lV2lkdGggPiAwO1xuICAgIHZhciBkcmF3QmFja2dyb3VuZCA9IGZpbGxDb2xvciB8fCBmaWxsQ29sb3IgPT09IDA7XG4gICAgaWYgKGRyYXdMaW5lICYmIGRyYXdCYWNrZ3JvdW5kKSB7XG4gICAgICAgIHJldHVybiAnREYnOyAvLyBGaWxsIHRoZW4gc3Ryb2tlXG4gICAgfVxuICAgIGVsc2UgaWYgKGRyYXdMaW5lKSB7XG4gICAgICAgIHJldHVybiAnUyc7IC8vIE9ubHkgc3Ryb2tlICh0cmFuc3BhcmVudCBiYWNrZ3JvdW5kKVxuICAgIH1cbiAgICBlbHNlIGlmIChkcmF3QmFja2dyb3VuZCkge1xuICAgICAgICByZXR1cm4gJ0YnOyAvLyBPbmx5IGZpbGwsIG5vIHN0cm9rZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VTcGFjaW5nKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgdmFsdWUgPSB2YWx1ZSB8fCBkZWZhdWx0VmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB2YWx1ZVsxXSxcbiAgICAgICAgICAgICAgICBib3R0b206IHZhbHVlWzJdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHZhbHVlWzNdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiB2YWx1ZVswXSxcbiAgICAgICAgICAgICAgICByaWdodDogdmFsdWVbMV0sXG4gICAgICAgICAgICAgICAgYm90dG9tOiB2YWx1ZVsyXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiB2YWx1ZVsxXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvcDogdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHZhbHVlWzFdLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgbGVmdDogdmFsdWVbMV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUudmVydGljYWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWx1ZS50b3AgPSB2YWx1ZS52ZXJ0aWNhbDtcbiAgICAgICAgICAgIHZhbHVlLmJvdHRvbSA9IHZhbHVlLnZlcnRpY2FsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUuaG9yaXpvbnRhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbHVlLnJpZ2h0ID0gdmFsdWUuaG9yaXpvbnRhbDtcbiAgICAgICAgICAgIHZhbHVlLmxlZnQgPSB2YWx1ZS5ob3Jpem9udGFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAoX2EgPSB2YWx1ZS5sZWZ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICB0b3A6IChfYiA9IHZhbHVlLnRvcCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdFZhbHVlLFxuICAgICAgICAgICAgcmlnaHQ6IChfYyA9IHZhbHVlLnJpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICBib3R0b206IChfZCA9IHZhbHVlLmJvdHRvbSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGVmYXVsdFZhbHVlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdG9wOiB2YWx1ZSwgcmlnaHQ6IHZhbHVlLCBib3R0b206IHZhbHVlLCBsZWZ0OiB2YWx1ZSB9O1xufVxuZnVuY3Rpb24gZ2V0UGFnZUF2YWlsYWJsZVdpZHRoKGRvYywgdGFibGUpIHtcbiAgICB2YXIgbWFyZ2lucyA9IHBhcnNlU3BhY2luZyh0YWJsZS5zZXR0aW5ncy5tYXJnaW4sIDApO1xuICAgIHJldHVybiBkb2MucGFnZVNpemUoKS53aWR0aCAtIChtYXJnaW5zLmxlZnQgKyBtYXJnaW5zLnJpZ2h0KTtcbn1cblxuLy8gTGltaXRhdGlvbnNcbi8vIC0gTm8gc3VwcG9ydCBmb3IgYm9yZGVyIHNwYWNpbmdcbi8vIC0gTm8gc3VwcG9ydCBmb3IgdHJhbnNwYXJlbmN5XG5mdW5jdGlvbiBwYXJzZUNzcyhzdXBwb3J0ZWRGb250cywgZWxlbWVudCwgc2NhbGVGYWN0b3IsIHN0eWxlLCB3aW5kb3cpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIHB4U2NhbGVGYWN0b3IgPSA5NiAvIDcyO1xuICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBwYXJzZUNvbG9yKGVsZW1lbnQsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKVsnYmFja2dyb3VuZENvbG9yJ107XG4gICAgfSk7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvciAhPSBudWxsKVxuICAgICAgICByZXN1bHQuZmlsbENvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICAgIHZhciB0ZXh0Q29sb3IgPSBwYXJzZUNvbG9yKGVsZW1lbnQsIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKVsnY29sb3InXTtcbiAgICB9KTtcbiAgICBpZiAodGV4dENvbG9yICE9IG51bGwpXG4gICAgICAgIHJlc3VsdC50ZXh0Q29sb3IgPSB0ZXh0Q29sb3I7XG4gICAgdmFyIHBhZGRpbmcgPSBwYXJzZVBhZGRpbmcoc3R5bGUsIHNjYWxlRmFjdG9yKTtcbiAgICBpZiAocGFkZGluZylcbiAgICAgICAgcmVzdWx0LmNlbGxQYWRkaW5nID0gcGFkZGluZztcbiAgICB2YXIgYm9yZGVyQ29sb3JTaWRlID0gJ2JvcmRlclRvcENvbG9yJztcbiAgICB2YXIgZmluYWxTY2FsZUZhY3RvciA9IHB4U2NhbGVGYWN0b3IgKiBzY2FsZUZhY3RvcjtcbiAgICB2YXIgYnR3ID0gc3R5bGUuYm9yZGVyVG9wV2lkdGg7XG4gICAgaWYgKHN0eWxlLmJvcmRlckJvdHRvbVdpZHRoID09PSBidHcgJiZcbiAgICAgICAgc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9PT0gYnR3ICYmXG4gICAgICAgIHN0eWxlLmJvcmRlckxlZnRXaWR0aCA9PT0gYnR3KSB7XG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IChwYXJzZUZsb2F0KGJ0dykgfHwgMCkgLyBmaW5hbFNjYWxlRmFjdG9yO1xuICAgICAgICBpZiAoYm9yZGVyV2lkdGgpXG4gICAgICAgICAgICByZXN1bHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQubGluZVdpZHRoID0ge1xuICAgICAgICAgICAgdG9wOiAocGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCkgfHwgMCkgLyBmaW5hbFNjYWxlRmFjdG9yLFxuICAgICAgICAgICAgcmlnaHQ6IChwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpIHx8IDApIC8gZmluYWxTY2FsZUZhY3RvcixcbiAgICAgICAgICAgIGJvdHRvbTogKHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpIHx8IDApIC8gZmluYWxTY2FsZUZhY3RvcixcbiAgICAgICAgICAgIGxlZnQ6IChwYXJzZUZsb2F0KHN0eWxlLmJvcmRlckxlZnRXaWR0aCkgfHwgMCkgLyBmaW5hbFNjYWxlRmFjdG9yLFxuICAgICAgICB9O1xuICAgICAgICAvLyBDaG9vc2UgYm9yZGVyIGNvbG9yIG9mIGZpcnN0IGF2YWlsYWJsZSBzaWRlXG4gICAgICAgIC8vIGNvdWxkIGJlIGltcHJvdmVkIGJ5IHN1cHBvcnRpbmcgb2JqZWN0IGFzIGxpbmVDb2xvclxuICAgICAgICBpZiAoIXJlc3VsdC5saW5lV2lkdGgudG9wKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmxpbmVXaWR0aC5yaWdodCkge1xuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yU2lkZSA9ICdib3JkZXJSaWdodENvbG9yJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5saW5lV2lkdGguYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQ29sb3JTaWRlID0gJ2JvcmRlckJvdHRvbUNvbG9yJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5saW5lV2lkdGgubGVmdCkge1xuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yU2lkZSA9ICdib3JkZXJMZWZ0Q29sb3InO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBib3JkZXJDb2xvciA9IHBhcnNlQ29sb3IoZWxlbWVudCwgZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pW2JvcmRlckNvbG9yU2lkZV07XG4gICAgfSk7XG4gICAgaWYgKGJvcmRlckNvbG9yICE9IG51bGwpXG4gICAgICAgIHJlc3VsdC5saW5lQ29sb3IgPSBib3JkZXJDb2xvcjtcbiAgICB2YXIgYWNjZXB0ZWQgPSBbJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJywgJ2p1c3RpZnknXTtcbiAgICBpZiAoYWNjZXB0ZWQuaW5kZXhPZihzdHlsZS50ZXh0QWxpZ24pICE9PSAtMSkge1xuICAgICAgICByZXN1bHQuaGFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgIH1cbiAgICBhY2NlcHRlZCA9IFsnbWlkZGxlJywgJ2JvdHRvbScsICd0b3AnXTtcbiAgICBpZiAoYWNjZXB0ZWQuaW5kZXhPZihzdHlsZS52ZXJ0aWNhbEFsaWduKSAhPT0gLTEpIHtcbiAgICAgICAgcmVzdWx0LnZhbGlnbiA9IHN0eWxlLnZlcnRpY2FsQWxpZ247XG4gICAgfVxuICAgIHZhciByZXMgPSBwYXJzZUludChzdHlsZS5mb250U2l6ZSB8fCAnJyk7XG4gICAgaWYgKCFpc05hTihyZXMpKVxuICAgICAgICByZXN1bHQuZm9udFNpemUgPSByZXMgLyBweFNjYWxlRmFjdG9yO1xuICAgIHZhciBmb250U3R5bGUgPSBwYXJzZUZvbnRTdHlsZShzdHlsZSk7XG4gICAgaWYgKGZvbnRTdHlsZSlcbiAgICAgICAgcmVzdWx0LmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICB2YXIgZm9udCA9IChzdHlsZS5mb250RmFtaWx5IHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChzdXBwb3J0ZWRGb250cy5pbmRleE9mKGZvbnQpICE9PSAtMSkge1xuICAgICAgICByZXN1bHQuZm9udCA9IGZvbnQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUZvbnRTdHlsZShzdHlsZSkge1xuICAgIHZhciByZXMgPSAnJztcbiAgICBpZiAoc3R5bGUuZm9udFdlaWdodCA9PT0gJ2JvbGQnIHx8XG4gICAgICAgIHN0eWxlLmZvbnRXZWlnaHQgPT09ICdib2xkZXInIHx8XG4gICAgICAgIHBhcnNlSW50KHN0eWxlLmZvbnRXZWlnaHQpID49IDcwMCkge1xuICAgICAgICByZXMgPSAnYm9sZCc7XG4gICAgfVxuICAgIGlmIChzdHlsZS5mb250U3R5bGUgPT09ICdpdGFsaWMnIHx8IHN0eWxlLmZvbnRTdHlsZSA9PT0gJ29ibGlxdWUnKSB7XG4gICAgICAgIHJlcyArPSAnaXRhbGljJztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHBhcnNlQ29sb3IoZWxlbWVudCwgc3R5bGVHZXR0ZXIpIHtcbiAgICB2YXIgY3NzQ29sb3IgPSByZWFsQ29sb3IoZWxlbWVudCwgc3R5bGVHZXR0ZXIpO1xuICAgIGlmICghY3NzQ29sb3IpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciByZ2JhID0gY3NzQ29sb3IubWF0Y2goL15yZ2JhP1xcKChcXGQrKSxcXHMqKFxcZCspLFxccyooXFxkKykoPzosXFxzKihcXGQqXFwuP1xcZCopKT9cXCkkLyk7XG4gICAgaWYgKCFyZ2JhIHx8ICFBcnJheS5pc0FycmF5KHJnYmEpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgY29sb3IgPSBbXG4gICAgICAgIHBhcnNlSW50KHJnYmFbMV0pLFxuICAgICAgICBwYXJzZUludChyZ2JhWzJdKSxcbiAgICAgICAgcGFyc2VJbnQocmdiYVszXSksXG4gICAgXTtcbiAgICB2YXIgYWxwaGEgPSBwYXJzZUludChyZ2JhWzRdKTtcbiAgICBpZiAoYWxwaGEgPT09IDAgfHwgaXNOYU4oY29sb3JbMF0pIHx8IGlzTmFOKGNvbG9yWzFdKSB8fCBpc05hTihjb2xvclsyXSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjb2xvcjtcbn1cbmZ1bmN0aW9uIHJlYWxDb2xvcihlbGVtLCBzdHlsZUdldHRlcikge1xuICAgIHZhciBiZyA9IHN0eWxlR2V0dGVyKGVsZW0pO1xuICAgIGlmIChiZyA9PT0gJ3JnYmEoMCwgMCwgMCwgMCknIHx8XG4gICAgICAgIGJnID09PSAndHJhbnNwYXJlbnQnIHx8XG4gICAgICAgIGJnID09PSAnaW5pdGlhbCcgfHxcbiAgICAgICAgYmcgPT09ICdpbmhlcml0Jykge1xuICAgICAgICBpZiAoZWxlbS5wYXJlbnRFbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWFsQ29sb3IoZWxlbS5wYXJlbnRFbGVtZW50LCBzdHlsZUdldHRlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYmc7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VQYWRkaW5nKHN0eWxlLCBzY2FsZUZhY3Rvcikge1xuICAgIHZhciB2YWwgPSBbXG4gICAgICAgIHN0eWxlLnBhZGRpbmdUb3AsXG4gICAgICAgIHN0eWxlLnBhZGRpbmdSaWdodCxcbiAgICAgICAgc3R5bGUucGFkZGluZ0JvdHRvbSxcbiAgICAgICAgc3R5bGUucGFkZGluZ0xlZnQsXG4gICAgXTtcbiAgICB2YXIgcHhTY2FsZUZhY3RvciA9IDk2IC8gKDcyIC8gc2NhbGVGYWN0b3IpO1xuICAgIHZhciBsaW5lUGFkZGluZyA9IChwYXJzZUludChzdHlsZS5saW5lSGVpZ2h0KSAtIHBhcnNlSW50KHN0eWxlLmZvbnRTaXplKSkgLyBzY2FsZUZhY3RvciAvIDI7XG4gICAgdmFyIGlucHV0UGFkZGluZyA9IHZhbC5tYXAoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG4gfHwgJzAnKSAvIHB4U2NhbGVGYWN0b3I7XG4gICAgfSk7XG4gICAgdmFyIHBhZGRpbmcgPSBwYXJzZVNwYWNpbmcoaW5wdXRQYWRkaW5nLCAwKTtcbiAgICBpZiAobGluZVBhZGRpbmcgPiBwYWRkaW5nLnRvcCkge1xuICAgICAgICBwYWRkaW5nLnRvcCA9IGxpbmVQYWRkaW5nO1xuICAgIH1cbiAgICBpZiAobGluZVBhZGRpbmcgPiBwYWRkaW5nLmJvdHRvbSkge1xuICAgICAgICBwYWRkaW5nLmJvdHRvbSA9IGxpbmVQYWRkaW5nO1xuICAgIH1cbiAgICByZXR1cm4gcGFkZGluZztcbn1cblxuZnVuY3Rpb24gcGFyc2VIdG1sKGRvYywgaW5wdXQsIHdpbmRvdywgaW5jbHVkZUhpZGRlbkh0bWwsIHVzZUNzcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGluY2x1ZGVIaWRkZW5IdG1sID09PSB2b2lkIDApIHsgaW5jbHVkZUhpZGRlbkh0bWwgPSBmYWxzZTsgfVxuICAgIGlmICh1c2VDc3MgPT09IHZvaWQgMCkgeyB1c2VDc3MgPSBmYWxzZTsgfVxuICAgIHZhciB0YWJsZUVsZW1lbnQ7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGFibGVFbGVtZW50ID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaW5wdXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGFibGVFbGVtZW50ID0gaW5wdXQ7XG4gICAgfVxuICAgIHZhciBzdXBwb3J0ZWRGb250cyA9IE9iamVjdC5rZXlzKGRvYy5nZXRGb250TGlzdCgpKTtcbiAgICB2YXIgc2NhbGVGYWN0b3IgPSBkb2Muc2NhbGVGYWN0b3IoKTtcbiAgICB2YXIgaGVhZCA9IFtdLCBib2R5ID0gW10sIGZvb3QgPSBbXTtcbiAgICBpZiAoIXRhYmxlRWxlbWVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdIdG1sIHRhYmxlIGNvdWxkIG5vdCBiZSBmb3VuZCB3aXRoIGlucHV0OiAnLCBpbnB1dCk7XG4gICAgICAgIHJldHVybiB7IGhlYWQ6IGhlYWQsIGJvZHk6IGJvZHksIGZvb3Q6IGZvb3QgfTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWJsZUVsZW1lbnQucm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRhYmxlRWxlbWVudC5yb3dzW2ldO1xuICAgICAgICB2YXIgdGFnTmFtZSA9IChfYiA9IChfYSA9IGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGFnTmFtZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciByb3cgPSBwYXJzZVJvd0NvbnRlbnQoc3VwcG9ydGVkRm9udHMsIHNjYWxlRmFjdG9yLCB3aW5kb3csIGVsZW1lbnQsIGluY2x1ZGVIaWRkZW5IdG1sLCB1c2VDc3MpO1xuICAgICAgICBpZiAoIXJvdylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ3RoZWFkJykge1xuICAgICAgICAgICAgaGVhZC5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFnTmFtZSA9PT0gJ3Rmb290Jykge1xuICAgICAgICAgICAgZm9vdC5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBBZGQgdG8gYm9keSBib3RoIGlmIHBhcmVudCBpcyB0Ym9keSBvciB0YWJsZVxuICAgICAgICAgICAgYm9keS5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgaGVhZDogaGVhZCwgYm9keTogYm9keSwgZm9vdDogZm9vdCB9O1xufVxuZnVuY3Rpb24gcGFyc2VSb3dDb250ZW50KHN1cHBvcnRlZEZvbnRzLCBzY2FsZUZhY3Rvciwgd2luZG93LCByb3csIGluY2x1ZGVIaWRkZW4sIHVzZUNzcykge1xuICAgIHZhciByZXN1bHRSb3cgPSBuZXcgSHRtbFJvd0lucHV0KHJvdyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3cuY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNlbGwgPSByb3cuY2VsbHNbaV07XG4gICAgICAgIHZhciBzdHlsZV8xID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY2VsbCk7XG4gICAgICAgIGlmIChpbmNsdWRlSGlkZGVuIHx8IHN0eWxlXzEuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICB2YXIgY2VsbFN0eWxlcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh1c2VDc3MpIHtcbiAgICAgICAgICAgICAgICBjZWxsU3R5bGVzID0gcGFyc2VDc3Moc3VwcG9ydGVkRm9udHMsIGNlbGwsIHNjYWxlRmFjdG9yLCBzdHlsZV8xLCB3aW5kb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0Um93LnB1c2goe1xuICAgICAgICAgICAgICAgIHJvd1NwYW46IGNlbGwucm93U3BhbixcbiAgICAgICAgICAgICAgICBjb2xTcGFuOiBjZWxsLmNvbFNwYW4sXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBjZWxsU3R5bGVzLFxuICAgICAgICAgICAgICAgIF9lbGVtZW50OiBjZWxsLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHBhcnNlQ2VsbENvbnRlbnQoY2VsbCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShyb3cpO1xuICAgIGlmIChyZXN1bHRSb3cubGVuZ3RoID4gMCAmJiAoaW5jbHVkZUhpZGRlbiB8fCBzdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRSb3c7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VDZWxsQ29udGVudChvcmdDZWxsKSB7XG4gICAgLy8gV29yayBvbiBjbG9uZWQgbm9kZSB0byBtYWtlIHN1cmUgbm8gY2hhbmdlcyBhcmUgYXBwbGllZCB0byBodG1sIHRhYmxlXG4gICAgdmFyIGNlbGwgPSBvcmdDZWxsLmNsb25lTm9kZSh0cnVlKTtcbiAgICAvLyBSZW1vdmUgZXh0cmEgc3BhY2UgYW5kIGxpbmUgYnJlYWtzIGluIG1hcmt1cCB0byBtYWtlIGl0IG1vcmUgc2ltaWxhciB0b1xuICAgIC8vIHdoYXQgd291bGQgYmUgc2hvd24gaW4gaHRtbFxuICAgIGNlbGwuaW5uZXJIVE1MID0gY2VsbC5pbm5lckhUTUwucmVwbGFjZSgvXFxuL2csICcnKS5yZXBsYWNlKC8gKy9nLCAnICcpO1xuICAgIC8vIFByZXNlcnZlIDxicj4gdGFncyBhcyBsaW5lIGJyZWFrcyBpbiB0aGUgcGRmXG4gICAgY2VsbC5pbm5lckhUTUwgPSBjZWxsLmlubmVySFRNTFxuICAgICAgICAuc3BsaXQoLzxici4qPz4vKSAvL3N0YXJ0IHdpdGggJzxicicgYW5kIGVuZHMgd2l0aCAnPicuXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhcnQpIHsgcmV0dXJuIHBhcnQudHJpbSgpOyB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG4gICAgLy8gaW5uZXJUZXh0IGZvciBpZVxuICAgIHJldHVybiBjZWxsLmlubmVyVGV4dCB8fCBjZWxsLnRleHRDb250ZW50IHx8ICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUlucHV0KGdsb2JhbCwgZG9jdW1lbnQsIGN1cnJlbnQpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gW2dsb2JhbCwgZG9jdW1lbnQsIGN1cnJlbnRdOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IF9hW19pXTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgb3B0aW9ucyBwYXJhbWV0ZXIgc2hvdWxkIGJlIG9mIHR5cGUgb2JqZWN0LCBpczogJyArIHR5cGVvZiBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zdGFydFkgJiYgdHlwZW9mIG9wdGlvbnMuc3RhcnRZICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCB2YWx1ZSBmb3Igc3RhcnRZIG9wdGlvbicsIG9wdGlvbnMuc3RhcnRZKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnN0YXJ0WTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzLCBzMSwgczIsIHMzKSB7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgIH1cbiAgICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgaWYgKG5leHRTb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gU2tpcCBvdmVyIGlmIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIG5leHRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCBidWdzIHdoZW4gaGFzT3duUHJvcGVydHkgaXMgc2hhZG93ZWRcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHRTb3VyY2UsIG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvO1xufVxuXG5mdW5jdGlvbiBwYXJzZUlucHV0KGQsIGN1cnJlbnQpIHtcbiAgICB2YXIgZG9jID0gbmV3IERvY0hhbmRsZXIoZCk7XG4gICAgdmFyIGRvY3VtZW50ID0gZG9jLmdldERvY3VtZW50T3B0aW9ucygpO1xuICAgIHZhciBnbG9iYWwgPSBkb2MuZ2V0R2xvYmFsT3B0aW9ucygpO1xuICAgIHZhbGlkYXRlSW5wdXQoZ2xvYmFsLCBkb2N1bWVudCwgY3VycmVudCk7XG4gICAgdmFyIG9wdGlvbnMgPSBhc3NpZ24oe30sIGdsb2JhbCwgZG9jdW1lbnQsIGN1cnJlbnQpO1xuICAgIHZhciB3aW47XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbiA9IHdpbmRvdztcbiAgICB9XG4gICAgdmFyIHN0eWxlcyA9IHBhcnNlU3R5bGVzKGdsb2JhbCwgZG9jdW1lbnQsIGN1cnJlbnQpO1xuICAgIHZhciBob29rcyA9IHBhcnNlSG9va3MoZ2xvYmFsLCBkb2N1bWVudCwgY3VycmVudCk7XG4gICAgdmFyIHNldHRpbmdzID0gcGFyc2VTZXR0aW5ncyhkb2MsIG9wdGlvbnMpO1xuICAgIHZhciBjb250ZW50ID0gcGFyc2VDb250ZW50JDEoZG9jLCBvcHRpb25zLCB3aW4pO1xuICAgIHJldHVybiB7IGlkOiBjdXJyZW50LnRhYmxlSWQsIGNvbnRlbnQ6IGNvbnRlbnQsIGhvb2tzOiBob29rcywgc3R5bGVzOiBzdHlsZXMsIHNldHRpbmdzOiBzZXR0aW5ncyB9O1xufVxuZnVuY3Rpb24gcGFyc2VTdHlsZXMoZ0lucHV0LCBkSW5wdXQsIGNJbnB1dCkge1xuICAgIHZhciBzdHlsZU9wdGlvbnMgPSB7XG4gICAgICAgIHN0eWxlczoge30sXG4gICAgICAgIGhlYWRTdHlsZXM6IHt9LFxuICAgICAgICBib2R5U3R5bGVzOiB7fSxcbiAgICAgICAgZm9vdFN0eWxlczoge30sXG4gICAgICAgIGFsdGVybmF0ZVJvd1N0eWxlczoge30sXG4gICAgICAgIGNvbHVtblN0eWxlczoge30sXG4gICAgfTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wID09PSAnY29sdW1uU3R5bGVzJykge1xuICAgICAgICAgICAgdmFyIGdsb2JhbF8xID0gZ0lucHV0W3Byb3BdO1xuICAgICAgICAgICAgdmFyIGRvY3VtZW50XzEgPSBkSW5wdXRbcHJvcF07XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IGNJbnB1dFtwcm9wXTtcbiAgICAgICAgICAgIHN0eWxlT3B0aW9ucy5jb2x1bW5TdHlsZXMgPSBhc3NpZ24oe30sIGdsb2JhbF8xLCBkb2N1bWVudF8xLCBjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhbGxPcHRpb25zID0gW2dJbnB1dCwgZElucHV0LCBjSW5wdXRdO1xuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IGFsbE9wdGlvbnMubWFwKGZ1bmN0aW9uIChvcHRzKSB7IHJldHVybiBvcHRzW3Byb3BdIHx8IHt9OyB9KTtcbiAgICAgICAgICAgIHN0eWxlT3B0aW9uc1twcm9wXSA9IGFzc2lnbih7fSwgc3R5bGVzWzBdLCBzdHlsZXNbMV0sIHN0eWxlc1syXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhzdHlsZU9wdGlvbnMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcHJvcCA9IF9hW19pXTtcbiAgICAgICAgX2xvb3BfMShwcm9wKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlT3B0aW9ucztcbn1cbmZ1bmN0aW9uIHBhcnNlSG9va3MoZ2xvYmFsLCBkb2N1bWVudCwgY3VycmVudCkge1xuICAgIHZhciBhbGxPcHRpb25zID0gW2dsb2JhbCwgZG9jdW1lbnQsIGN1cnJlbnRdO1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIGRpZFBhcnNlQ2VsbDogW10sXG4gICAgICAgIHdpbGxEcmF3Q2VsbDogW10sXG4gICAgICAgIGRpZERyYXdDZWxsOiBbXSxcbiAgICAgICAgd2lsbERyYXdQYWdlOiBbXSxcbiAgICAgICAgZGlkRHJhd1BhZ2U6IFtdLFxuICAgIH07XG4gICAgZm9yICh2YXIgX2kgPSAwLCBhbGxPcHRpb25zXzEgPSBhbGxPcHRpb25zOyBfaSA8IGFsbE9wdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhbGxPcHRpb25zXzFbX2ldO1xuICAgICAgICBpZiAob3B0aW9ucy5kaWRQYXJzZUNlbGwpXG4gICAgICAgICAgICByZXN1bHQuZGlkUGFyc2VDZWxsLnB1c2gob3B0aW9ucy5kaWRQYXJzZUNlbGwpO1xuICAgICAgICBpZiAob3B0aW9ucy53aWxsRHJhd0NlbGwpXG4gICAgICAgICAgICByZXN1bHQud2lsbERyYXdDZWxsLnB1c2gob3B0aW9ucy53aWxsRHJhd0NlbGwpO1xuICAgICAgICBpZiAob3B0aW9ucy5kaWREcmF3Q2VsbClcbiAgICAgICAgICAgIHJlc3VsdC5kaWREcmF3Q2VsbC5wdXNoKG9wdGlvbnMuZGlkRHJhd0NlbGwpO1xuICAgICAgICBpZiAob3B0aW9ucy53aWxsRHJhd1BhZ2UpXG4gICAgICAgICAgICByZXN1bHQud2lsbERyYXdQYWdlLnB1c2gob3B0aW9ucy53aWxsRHJhd1BhZ2UpO1xuICAgICAgICBpZiAob3B0aW9ucy5kaWREcmF3UGFnZSlcbiAgICAgICAgICAgIHJlc3VsdC5kaWREcmF3UGFnZS5wdXNoKG9wdGlvbnMuZGlkRHJhd1BhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VTZXR0aW5ncyhkb2MsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbTtcbiAgICB2YXIgbWFyZ2luID0gcGFyc2VTcGFjaW5nKG9wdGlvbnMubWFyZ2luLCA0MCAvIGRvYy5zY2FsZUZhY3RvcigpKTtcbiAgICB2YXIgc3RhcnRZID0gKF9hID0gZ2V0U3RhcnRZKGRvYywgb3B0aW9ucy5zdGFydFkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBtYXJnaW4udG9wO1xuICAgIHZhciBzaG93Rm9vdDtcbiAgICBpZiAob3B0aW9ucy5zaG93Rm9vdCA9PT0gdHJ1ZSkge1xuICAgICAgICBzaG93Rm9vdCA9ICdldmVyeVBhZ2UnO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLnNob3dGb290ID09PSBmYWxzZSkge1xuICAgICAgICBzaG93Rm9vdCA9ICduZXZlcic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzaG93Rm9vdCA9IChfYiA9IG9wdGlvbnMuc2hvd0Zvb3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdldmVyeVBhZ2UnO1xuICAgIH1cbiAgICB2YXIgc2hvd0hlYWQ7XG4gICAgaWYgKG9wdGlvbnMuc2hvd0hlYWQgPT09IHRydWUpIHtcbiAgICAgICAgc2hvd0hlYWQgPSAnZXZlcnlQYWdlJztcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5zaG93SGVhZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgc2hvd0hlYWQgPSAnbmV2ZXInO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2hvd0hlYWQgPSAoX2MgPSBvcHRpb25zLnNob3dIZWFkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnZXZlcnlQYWdlJztcbiAgICB9XG4gICAgdmFyIHVzZUNzcyA9IChfZCA9IG9wdGlvbnMudXNlQ3NzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZTtcbiAgICB2YXIgdGhlbWUgPSBvcHRpb25zLnRoZW1lIHx8ICh1c2VDc3MgPyAncGxhaW4nIDogJ3N0cmlwZWQnKTtcbiAgICB2YXIgaG9yaXpvbnRhbFBhZ2VCcmVhayA9ICEhb3B0aW9ucy5ob3Jpem9udGFsUGFnZUJyZWFrO1xuICAgIHZhciBob3Jpem9udGFsUGFnZUJyZWFrUmVwZWF0ID0gKF9lID0gb3B0aW9ucy5ob3Jpem9udGFsUGFnZUJyZWFrUmVwZWF0KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGluY2x1ZGVIaWRkZW5IdG1sOiAoX2YgPSBvcHRpb25zLmluY2x1ZGVIaWRkZW5IdG1sKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBmYWxzZSxcbiAgICAgICAgdXNlQ3NzOiB1c2VDc3MsXG4gICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgc3RhcnRZOiBzdGFydFksXG4gICAgICAgIG1hcmdpbjogbWFyZ2luLFxuICAgICAgICBwYWdlQnJlYWs6IChfZyA9IG9wdGlvbnMucGFnZUJyZWFrKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiAnYXV0bycsXG4gICAgICAgIHJvd1BhZ2VCcmVhazogKF9oID0gb3B0aW9ucy5yb3dQYWdlQnJlYWspICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6ICdhdXRvJyxcbiAgICAgICAgdGFibGVXaWR0aDogKF9qID0gb3B0aW9ucy50YWJsZVdpZHRoKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiAnYXV0bycsXG4gICAgICAgIHNob3dIZWFkOiBzaG93SGVhZCxcbiAgICAgICAgc2hvd0Zvb3Q6IHNob3dGb290LFxuICAgICAgICB0YWJsZUxpbmVXaWR0aDogKF9rID0gb3B0aW9ucy50YWJsZUxpbmVXaWR0aCkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogMCxcbiAgICAgICAgdGFibGVMaW5lQ29sb3I6IChfbCA9IG9wdGlvbnMudGFibGVMaW5lQ29sb3IpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IDIwMCxcbiAgICAgICAgaG9yaXpvbnRhbFBhZ2VCcmVhazogaG9yaXpvbnRhbFBhZ2VCcmVhayxcbiAgICAgICAgaG9yaXpvbnRhbFBhZ2VCcmVha1JlcGVhdDogaG9yaXpvbnRhbFBhZ2VCcmVha1JlcGVhdCxcbiAgICAgICAgaG9yaXpvbnRhbFBhZ2VCcmVha0JlaGF2aW91cjogKF9tID0gb3B0aW9ucy5ob3Jpem9udGFsUGFnZUJyZWFrQmVoYXZpb3VyKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiAnYWZ0ZXJBbGxSb3dzJyxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U3RhcnRZKGRvYywgdXNlclN0YXJ0WSkge1xuICAgIHZhciBwcmV2aW91cyA9IGRvYy5nZXRMYXN0QXV0b1RhYmxlKCk7XG4gICAgdmFyIHNmID0gZG9jLnNjYWxlRmFjdG9yKCk7XG4gICAgdmFyIGN1cnJlbnRQYWdlID0gZG9jLnBhZ2VOdW1iZXIoKTtcbiAgICB2YXIgaXNTYW1lUGFnZUFzUHJldmlvdXNUYWJsZSA9IGZhbHNlO1xuICAgIGlmIChwcmV2aW91cyAmJiBwcmV2aW91cy5zdGFydFBhZ2VOdW1iZXIpIHtcbiAgICAgICAgdmFyIGVuZGluZ1BhZ2UgPSBwcmV2aW91cy5zdGFydFBhZ2VOdW1iZXIgKyBwcmV2aW91cy5wYWdlTnVtYmVyIC0gMTtcbiAgICAgICAgaXNTYW1lUGFnZUFzUHJldmlvdXNUYWJsZSA9IGVuZGluZ1BhZ2UgPT09IGN1cnJlbnRQYWdlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHVzZXJTdGFydFkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB1c2VyU3RhcnRZO1xuICAgIH1cbiAgICBlbHNlIGlmICh1c2VyU3RhcnRZID09IG51bGwgfHwgdXNlclN0YXJ0WSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGlzU2FtZVBhZ2VBc1ByZXZpb3VzVGFibGUgJiYgKHByZXZpb3VzID09PSBudWxsIHx8IHByZXZpb3VzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2aW91cy5maW5hbFkpICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFNvbWUgdXNlcnMgaGFkIGlzc3VlcyB3aXRoIG92ZXJsYXBwaW5nIHRhYmxlcyB3aGVuIHRoZXkgdXNlZCBtdWx0aXBsZVxuICAgICAgICAgICAgLy8gdGFibGVzIHdpdGhvdXQgc2V0dGluZyBzdGFydFkgc28gc2V0dGluZyBpdCBoZXJlIHRvIGEgc2Vuc2libGUgZGVmYXVsdC5cbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91cy5maW5hbFkgKyAyMCAvIHNmO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VDb250ZW50JDEoZG9jLCBvcHRpb25zLCB3aW5kb3cpIHtcbiAgICB2YXIgaGVhZCA9IG9wdGlvbnMuaGVhZCB8fCBbXTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBbXTtcbiAgICB2YXIgZm9vdCA9IG9wdGlvbnMuZm9vdCB8fCBbXTtcbiAgICBpZiAob3B0aW9ucy5odG1sKSB7XG4gICAgICAgIHZhciBoaWRkZW4gPSBvcHRpb25zLmluY2x1ZGVIaWRkZW5IdG1sO1xuICAgICAgICBpZiAod2luZG93KSB7XG4gICAgICAgICAgICB2YXIgaHRtbENvbnRlbnQgPSBwYXJzZUh0bWwoZG9jLCBvcHRpb25zLmh0bWwsIHdpbmRvdywgaGlkZGVuLCBvcHRpb25zLnVzZUNzcykgfHwge307XG4gICAgICAgICAgICBoZWFkID0gaHRtbENvbnRlbnQuaGVhZCB8fCBoZWFkO1xuICAgICAgICAgICAgYm9keSA9IGh0bWxDb250ZW50LmJvZHkgfHwgaGVhZDtcbiAgICAgICAgICAgIGZvb3QgPSBodG1sQ29udGVudC5mb290IHx8IGhlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgcGFyc2UgaHRtbCBpbiBub24gYnJvd3NlciBlbnZpcm9ubWVudCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjb2x1bW5zID0gb3B0aW9ucy5jb2x1bW5zIHx8IHBhcnNlQ29sdW1ucyhoZWFkLCBib2R5LCBmb290KTtcbiAgICByZXR1cm4geyBjb2x1bW5zOiBjb2x1bW5zLCBoZWFkOiBoZWFkLCBib2R5OiBib2R5LCBmb290OiBmb290IH07XG59XG5mdW5jdGlvbiBwYXJzZUNvbHVtbnMoaGVhZCwgYm9keSwgZm9vdCkge1xuICAgIHZhciBmaXJzdFJvdyA9IGhlYWRbMF0gfHwgYm9keVswXSB8fCBmb290WzBdIHx8IFtdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhmaXJzdFJvdylcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgIT09ICdfZWxlbWVudCc7IH0pXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGNvbFNwYW4gPSAxO1xuICAgICAgICB2YXIgaW5wdXQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpcnN0Um93KSkge1xuICAgICAgICAgICAgaW5wdXQgPSBmaXJzdFJvd1twYXJzZUludChrZXkpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0ID0gZmlyc3RSb3dba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbFNwYW4gPSAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0LmNvbFNwYW4pIHx8IDE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xTcGFuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpcnN0Um93KSkge1xuICAgICAgICAgICAgICAgIGlkID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlkID0ga2V5ICsgKGkgPiAwID8gXCJfXCIuY29uY2F0KGkpIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJvd1Jlc3VsdCA9IHsgZGF0YUtleTogaWQgfTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJvd1Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgSG9va0RhdGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSG9va0RhdGEoZG9jLCB0YWJsZSwgY3Vyc29yKSB7XG4gICAgICAgIHRoaXMudGFibGUgPSB0YWJsZTtcbiAgICAgICAgdGhpcy5wYWdlTnVtYmVyID0gdGFibGUucGFnZU51bWJlcjtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHRhYmxlLnNldHRpbmdzO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGN1cnNvcjtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2MuZ2V0RG9jdW1lbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIEhvb2tEYXRhO1xufSgpKTtcbnZhciBDZWxsSG9va0RhdGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENlbGxIb29rRGF0YSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDZWxsSG9va0RhdGEoZG9jLCB0YWJsZSwgY2VsbCwgcm93LCBjb2x1bW4sIGN1cnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2MsIHRhYmxlLCBjdXJzb3IpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNlbGwgPSBjZWxsO1xuICAgICAgICBfdGhpcy5yb3cgPSByb3c7XG4gICAgICAgIF90aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgX3RoaXMuc2VjdGlvbiA9IHJvdy5zZWN0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDZWxsSG9va0RhdGE7XG59KEhvb2tEYXRhKSk7XG5cbnZhciBUYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWJsZShpbnB1dCwgY29udGVudCkge1xuICAgICAgICB0aGlzLnBhZ2VOdW1iZXIgPSAxO1xuICAgICAgICB0aGlzLmlkID0gaW5wdXQuaWQ7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBpbnB1dC5zZXR0aW5ncztcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBpbnB1dC5zdHlsZXM7XG4gICAgICAgIHRoaXMuaG9va3MgPSBpbnB1dC5ob29rcztcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gY29udGVudC5jb2x1bW5zO1xuICAgICAgICB0aGlzLmhlYWQgPSBjb250ZW50LmhlYWQ7XG4gICAgICAgIHRoaXMuYm9keSA9IGNvbnRlbnQuYm9keTtcbiAgICAgICAgdGhpcy5mb290ID0gY29udGVudC5mb290O1xuICAgIH1cbiAgICBUYWJsZS5wcm90b3R5cGUuZ2V0SGVhZEhlaWdodCA9IGZ1bmN0aW9uIChjb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWQucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHJvdykgeyByZXR1cm4gYWNjICsgcm93LmdldE1heENlbGxIZWlnaHQoY29sdW1ucyk7IH0sIDApO1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmdldEZvb3RIZWlnaHQgPSBmdW5jdGlvbiAoY29sdW1ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5mb290LnJlZHVjZShmdW5jdGlvbiAoYWNjLCByb3cpIHsgcmV0dXJuIGFjYyArIHJvdy5nZXRNYXhDZWxsSGVpZ2h0KGNvbHVtbnMpOyB9LCAwKTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5hbGxSb3dzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkLmNvbmNhdCh0aGlzLmJvZHkpLmNvbmNhdCh0aGlzLmZvb3QpO1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmNhbGxDZWxsSG9va3MgPSBmdW5jdGlvbiAoZG9jLCBoYW5kbGVycywgY2VsbCwgcm93LCBjb2x1bW4sIGN1cnNvcikge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGhhbmRsZXJzXzEgPSBoYW5kbGVyczsgX2kgPCBoYW5kbGVyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc18xW19pXTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gbmV3IENlbGxIb29rRGF0YShkb2MsIHRoaXMsIGNlbGwsIHJvdywgY29sdW1uLCBjdXJzb3IpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGhhbmRsZXIoZGF0YSkgPT09IGZhbHNlO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRleHQgaXMgYWx3YXlzIHN0cmluZ1tdIHNpbmNlIHVzZXIgY2FuIGFzc2lnbiBzdHJpbmdcbiAgICAgICAgICAgIGNlbGwudGV4dCA9IEFycmF5LmlzQXJyYXkoY2VsbC50ZXh0KSA/IGNlbGwudGV4dCA6IFtjZWxsLnRleHRdO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5jYWxsRW5kUGFnZUhvb2tzID0gZnVuY3Rpb24gKGRvYywgY3Vyc29yKSB7XG4gICAgICAgIGRvYy5hcHBseVN0eWxlcyhkb2MudXNlclN0eWxlcyk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmhvb2tzLmRpZERyYXdQYWdlOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBfYVtfaV07XG4gICAgICAgICAgICBoYW5kbGVyKG5ldyBIb29rRGF0YShkb2MsIHRoaXMsIGN1cnNvcikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWJsZS5wcm90b3R5cGUuY2FsbFdpbGxEcmF3UGFnZUhvb2tzID0gZnVuY3Rpb24gKGRvYywgY3Vyc29yKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmhvb2tzLndpbGxEcmF3UGFnZTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gX2FbX2ldO1xuICAgICAgICAgICAgaGFuZGxlcihuZXcgSG9va0RhdGEoZG9jLCB0aGlzLCBjdXJzb3IpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKHBhZ2VXaWR0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2V0dGluZ3MudGFibGVXaWR0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnRhYmxlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zZXR0aW5ncy50YWJsZVdpZHRoID09PSAnd3JhcCcpIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVkV2lkdGggPSB0aGlzLmNvbHVtbnMucmVkdWNlKGZ1bmN0aW9uICh0b3RhbCwgY29sKSB7IHJldHVybiB0b3RhbCArIGNvbC53cmFwcGVkV2lkdGg7IH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXJnaW4gPSB0aGlzLnNldHRpbmdzLm1hcmdpbjtcbiAgICAgICAgICAgIHJldHVybiBwYWdlV2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlO1xufSgpKTtcbnZhciBSb3cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUm93KHJhdywgaW5kZXgsIHNlY3Rpb24sIGNlbGxzLCBzcGFuc011bHRpcGxlUGFnZXMpIHtcbiAgICAgICAgaWYgKHNwYW5zTXVsdGlwbGVQYWdlcyA9PT0gdm9pZCAwKSB7IHNwYW5zTXVsdGlwbGVQYWdlcyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgICAgIGlmIChyYXcgaW5zdGFuY2VvZiBIdG1sUm93SW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMucmF3ID0gcmF3Ll9lbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gcmF3Ll9lbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zZWN0aW9uID0gc2VjdGlvbjtcbiAgICAgICAgdGhpcy5jZWxscyA9IGNlbGxzO1xuICAgICAgICB0aGlzLnNwYW5zTXVsdGlwbGVQYWdlcyA9IHNwYW5zTXVsdGlwbGVQYWdlcztcbiAgICB9XG4gICAgUm93LnByb3RvdHlwZS5nZXRNYXhDZWxsSGVpZ2h0ID0gZnVuY3Rpb24gKGNvbHVtbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNvbHVtbikgeyB2YXIgX2E7IHJldHVybiBNYXRoLm1heChhY2MsICgoX2EgPSBfdGhpcy5jZWxsc1tjb2x1bW4uaW5kZXhdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVpZ2h0KSB8fCAwKTsgfSwgMCk7XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLmhhc1Jvd1NwYW4gPSBmdW5jdGlvbiAoY29sdW1ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gX3RoaXMuY2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgICAgIGlmICghY2VsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gY2VsbC5yb3dTcGFuID4gMTtcbiAgICAgICAgfSkubGVuZ3RoID4gMCk7XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLmNhbkVudGlyZVJvd0ZpdCA9IGZ1bmN0aW9uIChoZWlnaHQsIGNvbHVtbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF4Q2VsbEhlaWdodChjb2x1bW5zKSA8PSBoZWlnaHQ7XG4gICAgfTtcbiAgICBSb3cucHJvdG90eXBlLmdldE1pbmltdW1Sb3dIZWlnaHQgPSBmdW5jdGlvbiAoY29sdW1ucywgZG9jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBjb2x1bW5zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gX3RoaXMuY2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgICAgIGlmICghY2VsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gZG9jLmdldExpbmVIZWlnaHQoY2VsbC5zdHlsZXMuZm9udFNpemUpO1xuICAgICAgICAgICAgdmFyIHZQYWRkaW5nID0gY2VsbC5wYWRkaW5nKCd2ZXJ0aWNhbCcpO1xuICAgICAgICAgICAgdmFyIG9uZVJvd0hlaWdodCA9IHZQYWRkaW5nICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgIHJldHVybiBvbmVSb3dIZWlnaHQgPiBhY2MgPyBvbmVSb3dIZWlnaHQgOiBhY2M7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgcmV0dXJuIFJvdztcbn0oKSk7XG52YXIgQ2VsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDZWxsKHJhdywgc3R5bGVzLCBzZWN0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5jb250ZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5jb250ZW50V2lkdGggPSAwO1xuICAgICAgICB0aGlzLndyYXBwZWRXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMubWluUmVhZGFibGVXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMubWluV2lkdGggPSAwO1xuICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgdGhpcy5zZWN0aW9uID0gc2VjdGlvbjtcbiAgICAgICAgdGhpcy5yYXcgPSByYXc7XG4gICAgICAgIHZhciBjb250ZW50ID0gcmF3O1xuICAgICAgICBpZiAocmF3ICE9IG51bGwgJiYgdHlwZW9mIHJhdyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmF3KSkge1xuICAgICAgICAgICAgdGhpcy5yb3dTcGFuID0gcmF3LnJvd1NwYW4gfHwgMTtcbiAgICAgICAgICAgIHRoaXMuY29sU3BhbiA9IHJhdy5jb2xTcGFuIHx8IDE7XG4gICAgICAgICAgICBjb250ZW50ID0gKF9hID0gcmF3LmNvbnRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJhdztcbiAgICAgICAgICAgIGlmIChyYXcuX2VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhdyA9IHJhdy5fZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm93U3BhbiA9IDE7XG4gICAgICAgICAgICB0aGlzLmNvbFNwYW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cmluZ2lmeSAwIGFuZCBmYWxzZSwgYnV0IG5vdCB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICB2YXIgdGV4dCA9IGNvbnRlbnQgIT0gbnVsbCA/ICcnICsgY29udGVudCA6ICcnO1xuICAgICAgICB2YXIgc3BsaXRSZWdleCA9IC9cXHJcXG58XFxyfFxcbi9nO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0LnNwbGl0KHNwbGl0UmVnZXgpO1xuICAgIH1cbiAgICBDZWxsLnByb3RvdHlwZS5nZXRUZXh0UG9zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeTtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzLnZhbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHkgPSB0aGlzLnkgKyB0aGlzLnBhZGRpbmcoJ3RvcCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3R5bGVzLnZhbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHkgPSB0aGlzLnkgKyB0aGlzLmhlaWdodCAtIHRoaXMucGFkZGluZygnYm90dG9tJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV0SGVpZ2h0ID0gdGhpcy5oZWlnaHQgLSB0aGlzLnBhZGRpbmcoJ3ZlcnRpY2FsJyk7XG4gICAgICAgICAgICB5ID0gdGhpcy55ICsgbmV0SGVpZ2h0IC8gMiArIHRoaXMucGFkZGluZygndG9wJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHg7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlcy5oYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHggPSB0aGlzLnggKyB0aGlzLndpZHRoIC0gdGhpcy5wYWRkaW5nKCdyaWdodCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3R5bGVzLmhhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHZhciBuZXRXaWR0aCA9IHRoaXMud2lkdGggLSB0aGlzLnBhZGRpbmcoJ2hvcml6b250YWwnKTtcbiAgICAgICAgICAgIHggPSB0aGlzLnggKyBuZXRXaWR0aCAvIDIgKyB0aGlzLnBhZGRpbmcoJ2xlZnQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggPSB0aGlzLnggKyB0aGlzLnBhZGRpbmcoJ2xlZnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgfTtcbiAgICAvLyBUT0RPICh2NCk6IHJlcGxhY2UgcGFyYW1ldGVycyB3aXRoIG9ubHkgKGxpbmVIZWlnaHQpXG4gICAgQ2VsbC5wcm90b3R5cGUuZ2V0Q29udGVudEhlaWdodCA9IGZ1bmN0aW9uIChzY2FsZUZhY3RvciwgbGluZUhlaWdodEZhY3Rvcikge1xuICAgICAgICBpZiAobGluZUhlaWdodEZhY3RvciA9PT0gdm9pZCAwKSB7IGxpbmVIZWlnaHRGYWN0b3IgPSAxLjE1OyB9XG4gICAgICAgIHZhciBsaW5lQ291bnQgPSBBcnJheS5pc0FycmF5KHRoaXMudGV4dCkgPyB0aGlzLnRleHQubGVuZ3RoIDogMTtcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSAodGhpcy5zdHlsZXMuZm9udFNpemUgLyBzY2FsZUZhY3RvcikgKiBsaW5lSGVpZ2h0RmFjdG9yO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gbGluZUNvdW50ICogbGluZUhlaWdodCArIHRoaXMucGFkZGluZygndmVydGljYWwnKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGhlaWdodCwgdGhpcy5zdHlsZXMubWluQ2VsbEhlaWdodCk7XG4gICAgfTtcbiAgICBDZWxsLnByb3RvdHlwZS5wYWRkaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBwYXJzZVNwYWNpbmcodGhpcy5zdHlsZXMuY2VsbFBhZGRpbmcsIDApO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYWRkaW5nW25hbWVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2VsbDtcbn0oKSk7XG52YXIgQ29sdW1uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbHVtbihkYXRhS2V5LCByYXcsIGluZGV4KSB7XG4gICAgICAgIHRoaXMud3JhcHBlZFdpZHRoID0gMDtcbiAgICAgICAgdGhpcy5taW5SZWFkYWJsZVdpZHRoID0gMDtcbiAgICAgICAgdGhpcy5taW5XaWR0aCA9IDA7XG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLmRhdGFLZXkgPSBkYXRhS2V5O1xuICAgICAgICB0aGlzLnJhdyA9IHJhdztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBDb2x1bW4ucHJvdG90eXBlLmdldE1heEN1c3RvbUNlbGxXaWR0aCA9IGZ1bmN0aW9uICh0YWJsZSkge1xuICAgICAgICB2YXIgbWF4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRhYmxlLmFsbFJvd3MoKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHJvdy5jZWxsc1t0aGlzLmluZGV4XTtcbiAgICAgICAgICAgIGlmIChjZWxsICYmIHR5cGVvZiBjZWxsLnN0eWxlcy5jZWxsV2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBjZWxsLnN0eWxlcy5jZWxsV2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfTtcbiAgICByZXR1cm4gQ29sdW1uO1xufSgpKTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGNvbHVtbiB3aWR0aHNcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlV2lkdGhzKGRvYywgdGFibGUpIHtcbiAgICBjYWxjdWxhdGUoZG9jLCB0YWJsZSk7XG4gICAgdmFyIHJlc2l6YWJsZUNvbHVtbnMgPSBbXTtcbiAgICB2YXIgaW5pdGlhbFRhYmxlV2lkdGggPSAwO1xuICAgIHRhYmxlLmNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIHZhciBjdXN0b21XaWR0aCA9IGNvbHVtbi5nZXRNYXhDdXN0b21DZWxsV2lkdGgodGFibGUpO1xuICAgICAgICBpZiAoY3VzdG9tV2lkdGgpIHtcbiAgICAgICAgICAgIC8vIGZpbmFsIGNvbHVtbiB3aWR0aFxuICAgICAgICAgICAgY29sdW1uLndpZHRoID0gY3VzdG9tV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbml0aWFsIGNvbHVtbiB3aWR0aCAod2lsbCBiZSByZXNpemVkKVxuICAgICAgICAgICAgY29sdW1uLndpZHRoID0gY29sdW1uLndyYXBwZWRXaWR0aDtcbiAgICAgICAgICAgIHJlc2l6YWJsZUNvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGluaXRpYWxUYWJsZVdpZHRoICs9IGNvbHVtbi53aWR0aDtcbiAgICB9KTtcbiAgICAvLyB3aWR0aCBkaWZmZXJlbmNlIHRoYXQgbmVlZHMgdG8gYmUgZGlzdHJpYnV0ZWRcbiAgICB2YXIgcmVzaXplV2lkdGggPSB0YWJsZS5nZXRXaWR0aChkb2MucGFnZVNpemUoKS53aWR0aCkgLSBpbml0aWFsVGFibGVXaWR0aDtcbiAgICAvLyBmaXJzdCByZXNpemUgYXR0ZW1wdDogd2l0aCByZXNwZWN0IHRvIG1pblJlYWRhYmxlV2lkdGggYW5kIG1pbldpZHRoXG4gICAgaWYgKHJlc2l6ZVdpZHRoKSB7XG4gICAgICAgIHJlc2l6ZVdpZHRoID0gcmVzaXplQ29sdW1ucyhyZXNpemFibGVDb2x1bW5zLCByZXNpemVXaWR0aCwgZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGNvbHVtbi5taW5SZWFkYWJsZVdpZHRoLCBjb2x1bW4ubWluV2lkdGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gc2Vjb25kIHJlc2l6ZSBhdHRlbXB0OiBpZ25vcmUgbWluUmVhZGFibGVXaWR0aCBidXQgcmVzcGVjdCBtaW5XaWR0aFxuICAgIGlmIChyZXNpemVXaWR0aCkge1xuICAgICAgICByZXNpemVXaWR0aCA9IHJlc2l6ZUNvbHVtbnMocmVzaXphYmxlQ29sdW1ucywgcmVzaXplV2lkdGgsIGZ1bmN0aW9uIChjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbi5taW5XaWR0aDsgfSk7XG4gICAgfVxuICAgIHJlc2l6ZVdpZHRoID0gTWF0aC5hYnMocmVzaXplV2lkdGgpO1xuICAgIGlmICghdGFibGUuc2V0dGluZ3MuaG9yaXpvbnRhbFBhZ2VCcmVhayAmJlxuICAgICAgICByZXNpemVXaWR0aCA+IDAuMSAvIGRvYy5zY2FsZUZhY3RvcigpKSB7XG4gICAgICAgIC8vIFRhYmxlIGNhbid0IGdldCBzbWFsbGVyIGR1ZSB0byBjdXN0b20td2lkdGggb3IgbWluV2lkdGggcmVzdHJpY3Rpb25zXG4gICAgICAgIC8vIFdlIGNhbid0IHJlYWxseSBkbyBtdWNoIGhlcmUuIFVwIHRvIHVzZXIgdG8gZm9yIGV4YW1wbGVcbiAgICAgICAgLy8gcmVkdWNlIGZvbnQgc2l6ZSwgaW5jcmVhc2UgcGFnZSBzaXplIG9yIHJlbW92ZSBjdXN0b20gY2VsbCB3aWR0aHNcbiAgICAgICAgLy8gdG8gYWxsb3cgbW9yZSBjb2x1bW5zIHRvIGJlIHJlZHVjZWQgaW4gc2l6ZVxuICAgICAgICByZXNpemVXaWR0aCA9IHJlc2l6ZVdpZHRoIDwgMSA/IHJlc2l6ZVdpZHRoIDogTWF0aC5yb3VuZChyZXNpemVXaWR0aCk7XG4gICAgICAgIGNvbnNvbGUud2FybihcIk9mIHRoZSB0YWJsZSBjb250ZW50LCBcIi5jb25jYXQocmVzaXplV2lkdGgsIFwiIHVuaXRzIHdpZHRoIGNvdWxkIG5vdCBmaXQgcGFnZVwiKSk7XG4gICAgfVxuICAgIGFwcGx5Q29sU3BhbnModGFibGUpO1xuICAgIGZpdENvbnRlbnQodGFibGUsIGRvYyk7XG4gICAgYXBwbHlSb3dTcGFucyh0YWJsZSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGUoZG9jLCB0YWJsZSkge1xuICAgIHZhciBzZiA9IGRvYy5zY2FsZUZhY3RvcigpO1xuICAgIHZhciBob3Jpem9udGFsUGFnZUJyZWFrID0gdGFibGUuc2V0dGluZ3MuaG9yaXpvbnRhbFBhZ2VCcmVhaztcbiAgICB2YXIgYXZhaWxhYmxlUGFnZVdpZHRoID0gZ2V0UGFnZUF2YWlsYWJsZVdpZHRoKGRvYywgdGFibGUpO1xuICAgIHRhYmxlLmFsbFJvd3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRhYmxlLmNvbHVtbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIGNlbGwgPSByb3cuY2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgICAgIGlmICghY2VsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBob29rcyA9IHRhYmxlLmhvb2tzLmRpZFBhcnNlQ2VsbDtcbiAgICAgICAgICAgIHRhYmxlLmNhbGxDZWxsSG9va3MoZG9jLCBob29rcywgY2VsbCwgcm93LCBjb2x1bW4sIG51bGwpO1xuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBjZWxsLnBhZGRpbmcoJ2hvcml6b250YWwnKTtcbiAgICAgICAgICAgIGNlbGwuY29udGVudFdpZHRoID0gZ2V0U3RyaW5nV2lkdGgoY2VsbC50ZXh0LCBjZWxsLnN0eWxlcywgZG9jKSArIHBhZGRpbmc7XG4gICAgICAgICAgICAvLyBVc2luZyBbXlxcU1xcdTAwQTBdIGluc3RlYWQgb2YgXFxzIGVuc3VyZXMgdGhhdCB3ZSBzcGxpdCB0aGUgdGV4dCBvbiBhbGxcbiAgICAgICAgICAgIC8vIHdoaXRlc3BhY2UgZXhjZXB0IG5vbi1icmVha2luZyBzcGFjZXMgKFxcdTAwQTApLiBXZSBuZWVkIHRvIHByZXNlcnZlXG4gICAgICAgICAgICAvLyB0aGVtIGluIHRoZSBzcGxpdCBwcm9jZXNzIHRvIGVuc3VyZSBjb3JyZWN0IHdvcmQgc2VwYXJhdGlvbiBhbmQgd2lkdGhcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0aW9uLlxuICAgICAgICAgICAgdmFyIGxvbmdlc3RXb3JkV2lkdGggPSBnZXRTdHJpbmdXaWR0aChjZWxsLnRleHQuam9pbignICcpLnNwbGl0KC9bXlxcU1xcdTAwQTBdKy8pLCBjZWxsLnN0eWxlcywgZG9jKTtcbiAgICAgICAgICAgIGNlbGwubWluUmVhZGFibGVXaWR0aCA9IGxvbmdlc3RXb3JkV2lkdGggKyBjZWxsLnBhZGRpbmcoJ2hvcml6b250YWwnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2VsbC5zdHlsZXMuY2VsbFdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNlbGwubWluV2lkdGggPSBjZWxsLnN0eWxlcy5jZWxsV2lkdGg7XG4gICAgICAgICAgICAgICAgY2VsbC53cmFwcGVkV2lkdGggPSBjZWxsLnN0eWxlcy5jZWxsV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjZWxsLnN0eWxlcy5jZWxsV2lkdGggPT09ICd3cmFwJyB8fFxuICAgICAgICAgICAgICAgIGhvcml6b250YWxQYWdlQnJlYWsgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBjZWxsIHdpZHRoIHNob3VsZCBub3QgYmUgbW9yZSB0aGFuIGF2YWlsYWJsZSBwYWdlIHdpZHRoXG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuY29udGVudFdpZHRoID4gYXZhaWxhYmxlUGFnZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwubWluV2lkdGggPSBhdmFpbGFibGVQYWdlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwud3JhcHBlZFdpZHRoID0gYXZhaWxhYmxlUGFnZVdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbC5taW5XaWR0aCA9IGNlbGwuY29udGVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjZWxsLndyYXBwZWRXaWR0aCA9IGNlbGwuY29udGVudFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGF1dG9cbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdE1pbldpZHRoID0gMTAgLyBzZjtcbiAgICAgICAgICAgICAgICBjZWxsLm1pbldpZHRoID0gY2VsbC5zdHlsZXMubWluQ2VsbFdpZHRoIHx8IGRlZmF1bHRNaW5XaWR0aDtcbiAgICAgICAgICAgICAgICBjZWxsLndyYXBwZWRXaWR0aCA9IGNlbGwuY29udGVudFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLm1pbldpZHRoID4gY2VsbC53cmFwcGVkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbC53cmFwcGVkV2lkdGggPSBjZWxsLm1pbldpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRhYmxlLmFsbFJvd3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRhYmxlLmNvbHVtbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIGNlbGwgPSByb3cuY2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgICAgIC8vIEZvciBub3cgd2UgaWdub3JlIHRoZSBtaW5XaWR0aCBhbmQgd3JhcHBlZFdpZHRoIG9mIGNvbHNwYW4gY2VsbHMgd2hlbiBjYWxjdWxhdGluZyBjb2xzcGFuIHdpZHRocy5cbiAgICAgICAgICAgIC8vIENvdWxkIHByb2JhYmx5IGJlIGltcHJvdmVkIHVwb24gaG93ZXZlci5cbiAgICAgICAgICAgIGlmIChjZWxsICYmIGNlbGwuY29sU3BhbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbi53cmFwcGVkV2lkdGggPSBNYXRoLm1heChjb2x1bW4ud3JhcHBlZFdpZHRoLCBjZWxsLndyYXBwZWRXaWR0aCk7XG4gICAgICAgICAgICAgICAgY29sdW1uLm1pbldpZHRoID0gTWF0aC5tYXgoY29sdW1uLm1pbldpZHRoLCBjZWxsLm1pbldpZHRoKTtcbiAgICAgICAgICAgICAgICBjb2x1bW4ubWluUmVhZGFibGVXaWR0aCA9IE1hdGgubWF4KGNvbHVtbi5taW5SZWFkYWJsZVdpZHRoLCBjZWxsLm1pblJlYWRhYmxlV2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzcGVjdCBjZWxsV2lkdGggc2V0IGluIGNvbHVtblN0eWxlcyBldmVuIGlmIHRoZXJlIGlzIG5vIGNlbGxzIGZvciB0aGlzIGNvbHVtblxuICAgICAgICAgICAgICAgIC8vIG9yIGlmIHRoZSBjb2x1bW4gb25seSBoYXZlIGNvbHNwYW4gY2VsbHMuIFNpbmNlIHRoZSB3aWR0aCBvZiBjb2xzcGFuIGNlbGxzXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgYWZmZWN0IHRoZSB3aWR0aCBvZiBjb2x1bW5zLCBzZXR0aW5nIGNvbHVtblN0eWxlcyBjZWxsV2lkdGggZW5hYmxlcyB0aGVcbiAgICAgICAgICAgICAgICAvLyB1c2VyIHRvIGF0IGxlYXN0IGRvIGl0IG1hbnVhbGx5LlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIG5vdCBwZXJmZWN0IGZvciBub3cgc2luY2UgZm9yIGV4YW1wbGUgcm93IGFuZCB0YWJsZSBzdHlsZXMgYXJlXG4gICAgICAgICAgICAgICAgLy8gbm90IGFjY291bnRlZCBmb3JcbiAgICAgICAgICAgICAgICB2YXIgY29sdW1uU3R5bGVzID0gdGFibGUuc3R5bGVzLmNvbHVtblN0eWxlc1tjb2x1bW4uZGF0YUtleV0gfHxcbiAgICAgICAgICAgICAgICAgICAgdGFibGUuc3R5bGVzLmNvbHVtblN0eWxlc1tjb2x1bW4uaW5kZXhdIHx8XG4gICAgICAgICAgICAgICAgICAgIHt9O1xuICAgICAgICAgICAgICAgIHZhciBjZWxsV2lkdGggPSBjb2x1bW5TdHlsZXMuY2VsbFdpZHRoIHx8IGNvbHVtblN0eWxlcy5taW5DZWxsV2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxXaWR0aCAmJiB0eXBlb2YgY2VsbFdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ubWluV2lkdGggPSBjZWxsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi53cmFwcGVkV2lkdGggPSBjZWxsV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIGNvbHVtbnMgZ2V0IGF0IGxlYXN0IG1pbiB3aWR0aCBldmVuIHRob3VnaCB3aWR0aCBjYWxjdWxhdGlvbnMgYXJlIG5vdCBiYXNlZCBvbiB0aGVtXG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuY29sU3BhbiA+IDEgJiYgIWNvbHVtbi5taW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ubWluV2lkdGggPSBjZWxsLm1pbldpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2VsbC5jb2xTcGFuID4gMSAmJiAhY29sdW1uLndyYXBwZWRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ud3JhcHBlZFdpZHRoID0gY2VsbC5taW5XaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogRGlzdHJpYnV0ZSByZXNpemVXaWR0aCBvbiBwYXNzZWQgcmVzaXphYmxlIGNvbHVtbnNcbiAqL1xuZnVuY3Rpb24gcmVzaXplQ29sdW1ucyhjb2x1bW5zLCByZXNpemVXaWR0aCwgZ2V0TWluV2lkdGgpIHtcbiAgICB2YXIgaW5pdGlhbFJlc2l6ZVdpZHRoID0gcmVzaXplV2lkdGg7XG4gICAgdmFyIHN1bVdyYXBwZWRXaWR0aCA9IGNvbHVtbnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNvbHVtbikgeyByZXR1cm4gYWNjICsgY29sdW1uLndyYXBwZWRXaWR0aDsgfSwgMCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSBjb2x1bW5zW2ldO1xuICAgICAgICB2YXIgcmF0aW8gPSBjb2x1bW4ud3JhcHBlZFdpZHRoIC8gc3VtV3JhcHBlZFdpZHRoO1xuICAgICAgICB2YXIgc3VnZ2VzdGVkQ2hhbmdlID0gaW5pdGlhbFJlc2l6ZVdpZHRoICogcmF0aW87XG4gICAgICAgIHZhciBzdWdnZXN0ZWRXaWR0aCA9IGNvbHVtbi53aWR0aCArIHN1Z2dlc3RlZENoYW5nZTtcbiAgICAgICAgdmFyIG1pbldpZHRoID0gZ2V0TWluV2lkdGgoY29sdW1uKTtcbiAgICAgICAgdmFyIG5ld1dpZHRoID0gc3VnZ2VzdGVkV2lkdGggPCBtaW5XaWR0aCA/IG1pbldpZHRoIDogc3VnZ2VzdGVkV2lkdGg7XG4gICAgICAgIHJlc2l6ZVdpZHRoIC09IG5ld1dpZHRoIC0gY29sdW1uLndpZHRoO1xuICAgICAgICBjb2x1bW4ud2lkdGggPSBuZXdXaWR0aDtcbiAgICB9XG4gICAgcmVzaXplV2lkdGggPSBNYXRoLnJvdW5kKHJlc2l6ZVdpZHRoICogMWUxMCkgLyAxZTEwO1xuICAgIC8vIFJ1biB0aGUgcmVzaXplciBhZ2FpbiBpZiB0aGVyZSdzIHJlbWFpbmluZyB3aWR0aCBuZWVkc1xuICAgIC8vIHRvIGJlIGRpc3RyaWJ1dGVkIGFuZCB0aGVyZSdyZSBjb2x1bW5zIHRoYXQgY2FuIGJlIHJlc2l6ZWRcbiAgICBpZiAocmVzaXplV2lkdGgpIHtcbiAgICAgICAgdmFyIHJlc2l6YWJsZUNvbHVtbnMgPSBjb2x1bW5zLmZpbHRlcihmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzaXplV2lkdGggPCAwXG4gICAgICAgICAgICAgICAgPyBjb2x1bW4ud2lkdGggPiBnZXRNaW5XaWR0aChjb2x1bW4pIC8vIGNoZWNrIGlmIGNvbHVtbiBjYW4gc2hyaW5rXG4gICAgICAgICAgICAgICAgOiB0cnVlOyAvLyBjaGVjayBpZiBjb2x1bW4gY2FuIGdyb3dcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXNpemFibGVDb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzaXplV2lkdGggPSByZXNpemVDb2x1bW5zKHJlc2l6YWJsZUNvbHVtbnMsIHJlc2l6ZVdpZHRoLCBnZXRNaW5XaWR0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc2l6ZVdpZHRoO1xufVxuZnVuY3Rpb24gYXBwbHlSb3dTcGFucyh0YWJsZSkge1xuICAgIHZhciByb3dTcGFuQ2VsbHMgPSB7fTtcbiAgICB2YXIgY29sUm93U3BhbnNMZWZ0ID0gMTtcbiAgICB2YXIgYWxsID0gdGFibGUuYWxsUm93cygpO1xuICAgIGZvciAodmFyIHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCBhbGwubGVuZ3RoOyByb3dJbmRleCsrKSB7XG4gICAgICAgIHZhciByb3cgPSBhbGxbcm93SW5kZXhdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGFibGUuY29sdW1uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHJvd1NwYW5DZWxsc1tjb2x1bW4uaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGNvbFJvd1NwYW5zTGVmdCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb2xSb3dTcGFuc0xlZnQtLTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcm93LmNlbGxzW2NvbHVtbi5pbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jZWxsLmhlaWdodCArPSByb3cuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbFJvd1NwYW5zTGVmdCA9IGRhdGEuY2VsbC5jb2xTcGFuO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByb3cuY2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgICAgICAgICBkYXRhLmxlZnQtLTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZWZ0IDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJvd1NwYW5DZWxsc1tjb2x1bW4uaW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsID0gcm93LmNlbGxzW2NvbHVtbi5pbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZWxsLmhlaWdodCA9IHJvdy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwucm93U3BhbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IGFsbC5sZW5ndGggLSByb3dJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBjZWxsLnJvd1NwYW4gPiByZW1haW5pbmcgPyByZW1haW5pbmcgOiBjZWxsLnJvd1NwYW47XG4gICAgICAgICAgICAgICAgICAgIHJvd1NwYW5DZWxsc1tjb2x1bW4uaW5kZXhdID0geyBjZWxsOiBjZWxsLCBsZWZ0OiBsZWZ0LCByb3c6IHJvdyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5Q29sU3BhbnModGFibGUpIHtcbiAgICB2YXIgYWxsID0gdGFibGUuYWxsUm93cygpO1xuICAgIGZvciAodmFyIHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCBhbGwubGVuZ3RoOyByb3dJbmRleCsrKSB7XG4gICAgICAgIHZhciByb3cgPSBhbGxbcm93SW5kZXhdO1xuICAgICAgICB2YXIgY29sU3BhbkNlbGwgPSBudWxsO1xuICAgICAgICB2YXIgY29tYmluZWRDb2xTcGFuV2lkdGggPSAwO1xuICAgICAgICB2YXIgY29sU3BhbnNMZWZ0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgY29sdW1uSW5kZXggPSAwOyBjb2x1bW5JbmRleCA8IHRhYmxlLmNvbHVtbnMubGVuZ3RoOyBjb2x1bW5JbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gdGFibGUuY29sdW1uc1tjb2x1bW5JbmRleF07XG4gICAgICAgICAgICAvLyBXaWR0aCBhbmQgY29sc3BhblxuICAgICAgICAgICAgY29sU3BhbnNMZWZ0IC09IDE7XG4gICAgICAgICAgICBpZiAoY29sU3BhbnNMZWZ0ID4gMSAmJiB0YWJsZS5jb2x1bW5zW2NvbHVtbkluZGV4ICsgMV0pIHtcbiAgICAgICAgICAgICAgICBjb21iaW5lZENvbFNwYW5XaWR0aCArPSBjb2x1bW4ud2lkdGg7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJvdy5jZWxsc1tjb2x1bW4uaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29sU3BhbkNlbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IGNvbFNwYW5DZWxsO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByb3cuY2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgICAgICAgICBjb2xTcGFuQ2VsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2VsbC53aWR0aCA9IGNvbHVtbi53aWR0aCArIGNvbWJpbmVkQ29sU3BhbldpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSByb3cuY2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoIWNlbGwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbFNwYW5zTGVmdCA9IGNlbGwuY29sU3BhbjtcbiAgICAgICAgICAgICAgICBjb21iaW5lZENvbFNwYW5XaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuY29sU3BhbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sU3BhbkNlbGwgPSBjZWxsO1xuICAgICAgICAgICAgICAgICAgICBjb21iaW5lZENvbFNwYW5XaWR0aCArPSBjb2x1bW4ud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZWxsLndpZHRoID0gY29sdW1uLndpZHRoICsgY29tYmluZWRDb2xTcGFuV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmaXRDb250ZW50KHRhYmxlLCBkb2MpIHtcbiAgICB2YXIgcm93U3BhbkhlaWdodCA9IHsgY291bnQ6IDAsIGhlaWdodDogMCB9O1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0YWJsZS5hbGxSb3dzKCk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByb3cgPSBfYVtfaV07XG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0YWJsZS5jb2x1bW5zOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IF9jW19iXTtcbiAgICAgICAgICAgIHZhciBjZWxsID0gcm93LmNlbGxzW2NvbHVtbi5pbmRleF07XG4gICAgICAgICAgICBpZiAoIWNlbGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBkb2MuYXBwbHlTdHlsZXMoY2VsbC5zdHlsZXMsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHRleHRTcGFjZSA9IGNlbGwud2lkdGggLSBjZWxsLnBhZGRpbmcoJ2hvcml6b250YWwnKTtcbiAgICAgICAgICAgIGlmIChjZWxsLnN0eWxlcy5vdmVyZmxvdyA9PT0gJ2xpbmVicmVhaycpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgb25lIHB0IHRvIHRleHRTcGFjZSB0byBmaXggcm91bmRpbmcgZXJyb3JcbiAgICAgICAgICAgICAgICBjZWxsLnRleHQgPSBkb2Muc3BsaXRUZXh0VG9TaXplKGNlbGwudGV4dCwgdGV4dFNwYWNlICsgMSAvIGRvYy5zY2FsZUZhY3RvcigpLCB7IGZvbnRTaXplOiBjZWxsLnN0eWxlcy5mb250U2l6ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNlbGwuc3R5bGVzLm92ZXJmbG93ID09PSAnZWxsaXBzaXplJykge1xuICAgICAgICAgICAgICAgIGNlbGwudGV4dCA9IGVsbGlwc2l6ZShjZWxsLnRleHQsIHRleHRTcGFjZSwgY2VsbC5zdHlsZXMsIGRvYywgJy4uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2VsbC5zdHlsZXMub3ZlcmZsb3cgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgY2VsbC50ZXh0ID0gZWxsaXBzaXplKGNlbGwudGV4dCwgdGV4dFNwYWNlLCBjZWxsLnN0eWxlcywgZG9jLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2VsbC5zdHlsZXMub3ZlcmZsb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2VsbC5zdHlsZXMub3ZlcmZsb3coY2VsbC50ZXh0LCB0ZXh0U3BhY2UpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjZWxsLnRleHQgPSBbcmVzdWx0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwudGV4dCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsLmNvbnRlbnRIZWlnaHQgPSBjZWxsLmdldENvbnRlbnRIZWlnaHQoZG9jLnNjYWxlRmFjdG9yKCksIGRvYy5nZXRMaW5lSGVpZ2h0RmFjdG9yKCkpO1xuICAgICAgICAgICAgdmFyIHJlYWxDb250ZW50SGVpZ2h0ID0gY2VsbC5jb250ZW50SGVpZ2h0IC8gY2VsbC5yb3dTcGFuO1xuICAgICAgICAgICAgaWYgKGNlbGwucm93U3BhbiA+IDEgJiZcbiAgICAgICAgICAgICAgICByb3dTcGFuSGVpZ2h0LmNvdW50ICogcm93U3BhbkhlaWdodC5oZWlnaHQgPFxuICAgICAgICAgICAgICAgICAgICByZWFsQ29udGVudEhlaWdodCAqIGNlbGwucm93U3Bhbikge1xuICAgICAgICAgICAgICAgIHJvd1NwYW5IZWlnaHQgPSB7IGhlaWdodDogcmVhbENvbnRlbnRIZWlnaHQsIGNvdW50OiBjZWxsLnJvd1NwYW4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJvd1NwYW5IZWlnaHQgJiYgcm93U3BhbkhlaWdodC5jb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocm93U3BhbkhlaWdodC5oZWlnaHQgPiByZWFsQ29udGVudEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICByZWFsQ29udGVudEhlaWdodCA9IHJvd1NwYW5IZWlnaHQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWFsQ29udGVudEhlaWdodCA+IHJvdy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByb3cuaGVpZ2h0ID0gcmVhbENvbnRlbnRIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcm93U3BhbkhlaWdodC5jb3VudC0tO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsbGlwc2l6ZSh0ZXh0LCB3aWR0aCwgc3R5bGVzLCBkb2MsIG92ZXJmbG93KSB7XG4gICAgcmV0dXJuIHRleHQubWFwKGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGVsbGlwc2l6ZVN0cihzdHIsIHdpZHRoLCBzdHlsZXMsIGRvYywgb3ZlcmZsb3cpOyB9KTtcbn1cbmZ1bmN0aW9uIGVsbGlwc2l6ZVN0cih0ZXh0LCB3aWR0aCwgc3R5bGVzLCBkb2MsIG92ZXJmbG93KSB7XG4gICAgdmFyIHByZWNpc2lvbiA9IDEwMDAwICogZG9jLnNjYWxlRmFjdG9yKCk7XG4gICAgd2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICAgIGlmICh3aWR0aCA+PSBnZXRTdHJpbmdXaWR0aCh0ZXh0LCBzdHlsZXMsIGRvYykpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHdoaWxlICh3aWR0aCA8IGdldFN0cmluZ1dpZHRoKHRleHQgKyBvdmVyZmxvdywgc3R5bGVzLCBkb2MpKSB7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQudHJpbSgpICsgb3ZlcmZsb3c7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRhYmxlKGpzUERGRG9jLCBpbnB1dCkge1xuICAgIHZhciBkb2MgPSBuZXcgRG9jSGFuZGxlcihqc1BERkRvYyk7XG4gICAgdmFyIGNvbnRlbnQgPSBwYXJzZUNvbnRlbnQoaW5wdXQsIGRvYy5zY2FsZUZhY3RvcigpKTtcbiAgICB2YXIgdGFibGUgPSBuZXcgVGFibGUoaW5wdXQsIGNvbnRlbnQpO1xuICAgIGNhbGN1bGF0ZVdpZHRocyhkb2MsIHRhYmxlKTtcbiAgICBkb2MuYXBwbHlTdHlsZXMoZG9jLnVzZXJTdHlsZXMpO1xuICAgIHJldHVybiB0YWJsZTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29udGVudChpbnB1dCwgc2YpIHtcbiAgICB2YXIgY29udGVudCA9IGlucHV0LmNvbnRlbnQ7XG4gICAgdmFyIGNvbHVtbnMgPSBjcmVhdGVDb2x1bW5zKGNvbnRlbnQuY29sdW1ucyk7XG4gICAgLy8gSWYgbm8gaGVhZCBvciBmb290IGlzIHNldCwgdHJ5IGdlbmVyYXRpbmcgaXQgd2l0aCBjb250ZW50IGZyb20gY29sdW1uc1xuICAgIGlmIChjb250ZW50LmhlYWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBzZWN0aW9uUm93ID0gZ2VuZXJhdGVTZWN0aW9uUm93KGNvbHVtbnMsICdoZWFkJyk7XG4gICAgICAgIGlmIChzZWN0aW9uUm93KVxuICAgICAgICAgICAgY29udGVudC5oZWFkLnB1c2goc2VjdGlvblJvdyk7XG4gICAgfVxuICAgIGlmIChjb250ZW50LmZvb3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBzZWN0aW9uUm93ID0gZ2VuZXJhdGVTZWN0aW9uUm93KGNvbHVtbnMsICdmb290Jyk7XG4gICAgICAgIGlmIChzZWN0aW9uUm93KVxuICAgICAgICAgICAgY29udGVudC5mb290LnB1c2goc2VjdGlvblJvdyk7XG4gICAgfVxuICAgIHZhciB0aGVtZSA9IGlucHV0LnNldHRpbmdzLnRoZW1lO1xuICAgIHZhciBzdHlsZXMgPSBpbnB1dC5zdHlsZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sdW1uczogY29sdW1ucyxcbiAgICAgICAgaGVhZDogcGFyc2VTZWN0aW9uKCdoZWFkJywgY29udGVudC5oZWFkLCBjb2x1bW5zLCBzdHlsZXMsIHRoZW1lLCBzZiksXG4gICAgICAgIGJvZHk6IHBhcnNlU2VjdGlvbignYm9keScsIGNvbnRlbnQuYm9keSwgY29sdW1ucywgc3R5bGVzLCB0aGVtZSwgc2YpLFxuICAgICAgICBmb290OiBwYXJzZVNlY3Rpb24oJ2Zvb3QnLCBjb250ZW50LmZvb3QsIGNvbHVtbnMsIHN0eWxlcywgdGhlbWUsIHNmKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VTZWN0aW9uKHNlY3Rpb25OYW1lLCBzZWN0aW9uUm93cywgY29sdW1ucywgc3R5bGVQcm9wcywgdGhlbWUsIHNjYWxlRmFjdG9yKSB7XG4gICAgdmFyIHJvd1NwYW5zTGVmdEZvckNvbHVtbiA9IHt9O1xuICAgIHZhciByZXN1bHQgPSBzZWN0aW9uUm93cy5tYXAoZnVuY3Rpb24gKHJhd1Jvdywgcm93SW5kZXgpIHtcbiAgICAgICAgdmFyIHNraXBwZWRSb3dGb3JSb3dTcGFucyA9IDA7XG4gICAgICAgIHZhciBjZWxscyA9IHt9O1xuICAgICAgICB2YXIgY29sU3BhbnNBZGRlZCA9IDA7XG4gICAgICAgIHZhciBjb2x1bW5TcGFuc0xlZnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNvbHVtbnNfMSA9IGNvbHVtbnM7IF9pIDwgY29sdW1uc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbnNfMVtfaV07XG4gICAgICAgICAgICBpZiAocm93U3BhbnNMZWZ0Rm9yQ29sdW1uW2NvbHVtbi5pbmRleF0gPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHJvd1NwYW5zTGVmdEZvckNvbHVtbltjb2x1bW4uaW5kZXhdLmxlZnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uU3BhbnNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYXdDZWxsID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYXdSb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdDZWxsID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdSb3dbY29sdW1uLmluZGV4IC0gY29sU3BhbnNBZGRlZCAtIHNraXBwZWRSb3dGb3JSb3dTcGFuc107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdDZWxsID0gcmF3Um93W2NvbHVtbi5kYXRhS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbElucHV0U3R5bGVzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmF3Q2VsbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmF3Q2VsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxJbnB1dFN0eWxlcyA9IChyYXdDZWxsID09PSBudWxsIHx8IHJhd0NlbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJhd0NlbGwuc3R5bGVzKSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gY2VsbFN0eWxlcyhzZWN0aW9uTmFtZSwgY29sdW1uLCByb3dJbmRleCwgdGhlbWUsIHN0eWxlUHJvcHMsIHNjYWxlRmFjdG9yLCBjZWxsSW5wdXRTdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IG5ldyBDZWxsKHJhd0NlbGwsIHN0eWxlcywgc2VjdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBkYXRhS2V5IGlzIG5vdCB1c2VkIGludGVybmFsbHkgbm8gbW9yZSBidXQga2VlcCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBpbiBob29rc1xuICAgICAgICAgICAgICAgICAgICBjZWxsc1tjb2x1bW4uZGF0YUtleV0gPSBjZWxsO1xuICAgICAgICAgICAgICAgICAgICBjZWxsc1tjb2x1bW4uaW5kZXhdID0gY2VsbDtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uU3BhbnNMZWZ0ID0gY2VsbC5jb2xTcGFuIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgcm93U3BhbnNMZWZ0Rm9yQ29sdW1uW2NvbHVtbi5pbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjZWxsLnJvd1NwYW4gLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXM6IGNvbHVtblNwYW5zTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtblNwYW5zTGVmdC0tO1xuICAgICAgICAgICAgICAgICAgICBjb2xTcGFuc0FkZGVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm93U3BhbnNMZWZ0Rm9yQ29sdW1uW2NvbHVtbi5pbmRleF0ubGVmdC0tO1xuICAgICAgICAgICAgICAgIGNvbHVtblNwYW5zTGVmdCA9IHJvd1NwYW5zTGVmdEZvckNvbHVtbltjb2x1bW4uaW5kZXhdLnRpbWVzO1xuICAgICAgICAgICAgICAgIHNraXBwZWRSb3dGb3JSb3dTcGFucysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUm93KHJhd1Jvdywgcm93SW5kZXgsIHNlY3Rpb25OYW1lLCBjZWxscyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU2VjdGlvblJvdyhjb2x1bW5zLCBzZWN0aW9uKSB7XG4gICAgdmFyIHNlY3Rpb25Sb3cgPSB7fTtcbiAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICBpZiAoY29sLnJhdyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBnZXRTZWN0aW9uVGl0bGUoc2VjdGlvbiwgY29sLnJhdyk7XG4gICAgICAgICAgICBpZiAodGl0bGUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBzZWN0aW9uUm93W2NvbC5kYXRhS2V5XSA9IHRpdGxlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNlY3Rpb25Sb3cpLmxlbmd0aCA+IDAgPyBzZWN0aW9uUm93IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFNlY3Rpb25UaXRsZShzZWN0aW9uLCBjb2x1bW4pIHtcbiAgICBpZiAoc2VjdGlvbiA9PT0gJ2hlYWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29sdW1uID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5oZWFkZXIgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29sdW1uID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY29sdW1uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzZWN0aW9uID09PSAnZm9vdCcgJiYgdHlwZW9mIGNvbHVtbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbi5mb290ZXI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29sdW1ucyhjb2x1bW5zKSB7XG4gICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uIChpbnB1dCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAga2V5ID0gKF9hID0gaW5wdXQuZGF0YUtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbHVtbihrZXksIGlucHV0LCBpbmRleCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjZWxsU3R5bGVzKHNlY3Rpb25OYW1lLCBjb2x1bW4sIHJvd0luZGV4LCB0aGVtZU5hbWUsIHN0eWxlcywgc2NhbGVGYWN0b3IsIGNlbGxJbnB1dFN0eWxlcykge1xuICAgIHZhciB0aGVtZSA9IGdldFRoZW1lKHRoZW1lTmFtZSk7XG4gICAgdmFyIHNlY3Rpb25TdHlsZXM7XG4gICAgaWYgKHNlY3Rpb25OYW1lID09PSAnaGVhZCcpIHtcbiAgICAgICAgc2VjdGlvblN0eWxlcyA9IHN0eWxlcy5oZWFkU3R5bGVzO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWN0aW9uTmFtZSA9PT0gJ2JvZHknKSB7XG4gICAgICAgIHNlY3Rpb25TdHlsZXMgPSBzdHlsZXMuYm9keVN0eWxlcztcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VjdGlvbk5hbWUgPT09ICdmb290Jykge1xuICAgICAgICBzZWN0aW9uU3R5bGVzID0gc3R5bGVzLmZvb3RTdHlsZXM7XG4gICAgfVxuICAgIHZhciBvdGhlclN0eWxlcyA9IGFzc2lnbih7fSwgdGhlbWUudGFibGUsIHRoZW1lW3NlY3Rpb25OYW1lXSwgc3R5bGVzLnN0eWxlcywgc2VjdGlvblN0eWxlcyk7XG4gICAgdmFyIGNvbHVtblN0eWxlcyA9IHN0eWxlcy5jb2x1bW5TdHlsZXNbY29sdW1uLmRhdGFLZXldIHx8XG4gICAgICAgIHN0eWxlcy5jb2x1bW5TdHlsZXNbY29sdW1uLmluZGV4XSB8fFxuICAgICAgICB7fTtcbiAgICB2YXIgY29sU3R5bGVzID0gc2VjdGlvbk5hbWUgPT09ICdib2R5JyA/IGNvbHVtblN0eWxlcyA6IHt9O1xuICAgIHZhciByb3dTdHlsZXMgPSBzZWN0aW9uTmFtZSA9PT0gJ2JvZHknICYmIHJvd0luZGV4ICUgMiA9PT0gMFxuICAgICAgICA/IGFzc2lnbih7fSwgdGhlbWUuYWx0ZXJuYXRlUm93LCBzdHlsZXMuYWx0ZXJuYXRlUm93U3R5bGVzKVxuICAgICAgICA6IHt9O1xuICAgIHZhciBkZWZhdWx0U3R5bGUgPSBkZWZhdWx0U3R5bGVzKHNjYWxlRmFjdG9yKTtcbiAgICB2YXIgdGhlbWVTdHlsZXMgPSBhc3NpZ24oe30sIGRlZmF1bHRTdHlsZSwgb3RoZXJTdHlsZXMsIHJvd1N0eWxlcywgY29sU3R5bGVzKTtcbiAgICByZXR1cm4gYXNzaWduKHRoZW1lU3R5bGVzLCBjZWxsSW5wdXRTdHlsZXMpO1xufVxuXG4vLyBnZXQgY29sdW1ucyBjYW4gYmUgZml0IGludG8gcGFnZVxuZnVuY3Rpb24gZ2V0Q29sdW1uc0NhbkZpdEluUGFnZShkb2MsIHRhYmxlLCBjb25maWcpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgLy8gR2V0IHBhZ2Ugd2lkdGhcbiAgICB2YXIgcmVtYWluaW5nV2lkdGggPSBnZXRQYWdlQXZhaWxhYmxlV2lkdGgoZG9jLCB0YWJsZSk7XG4gICAgLy8gR2V0IGNvbHVtbiBkYXRhIGtleSB0byByZXBlYXRcbiAgICB2YXIgcmVwZWF0Q29sdW1uc01hcCA9IG5ldyBNYXAoKTtcbiAgICB2YXIgY29sSW5kZXhlcyA9IFtdO1xuICAgIHZhciBjb2x1bW5zID0gW107XG4gICAgdmFyIGhvcml6b250YWxQYWdlQnJlYWtSZXBlYXQgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YWJsZS5zZXR0aW5ncy5ob3Jpem9udGFsUGFnZUJyZWFrUmVwZWF0KSkge1xuICAgICAgICBob3Jpem9udGFsUGFnZUJyZWFrUmVwZWF0ID0gdGFibGUuc2V0dGluZ3MuaG9yaXpvbnRhbFBhZ2VCcmVha1JlcGVhdDtcbiAgICAgICAgLy8gSXQgY2FuIGJlIGEgc2luZ2xlIHZhbHVlIG9mIHR5cGUgc3RyaW5nIG9yIG51bWJlciAoZXZlbiBudW1iZXI6IDApXG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB0YWJsZS5zZXR0aW5ncy5ob3Jpem9udGFsUGFnZUJyZWFrUmVwZWF0ID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgdGFibGUuc2V0dGluZ3MuaG9yaXpvbnRhbFBhZ2VCcmVha1JlcGVhdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaG9yaXpvbnRhbFBhZ2VCcmVha1JlcGVhdCA9IFt0YWJsZS5zZXR0aW5ncy5ob3Jpem9udGFsUGFnZUJyZWFrUmVwZWF0XTtcbiAgICB9XG4gICAgLy8gQ29kZSB0byByZXBlYXQgdGhlIGdpdmVuIGNvbHVtbiBpbiBzcGxpdCBwYWdlc1xuICAgIGhvcml6b250YWxQYWdlQnJlYWtSZXBlYXQuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgdmFyIGNvbCA9IHRhYmxlLmNvbHVtbnMuZmluZChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5kYXRhS2V5ID09PSBmaWVsZCB8fCBpdGVtLmluZGV4ID09PSBmaWVsZDsgfSk7XG4gICAgICAgIGlmIChjb2wgJiYgIXJlcGVhdENvbHVtbnNNYXAuaGFzKGNvbC5pbmRleCkpIHtcbiAgICAgICAgICAgIHJlcGVhdENvbHVtbnNNYXAuc2V0KGNvbC5pbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb2xJbmRleGVzLnB1c2goY29sLmluZGV4KTtcbiAgICAgICAgICAgIGNvbHVtbnMucHVzaCh0YWJsZS5jb2x1bW5zW2NvbC5pbmRleF0pO1xuICAgICAgICAgICAgcmVtYWluaW5nV2lkdGggLT0gY29sLndyYXBwZWRXaWR0aDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBmaXJzdCA9IHRydWU7XG4gICAgdmFyIGkgPSAoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuc3RhcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7IC8vIG1ha2Ugc3VyZSBjb3V0ZXIgaXMgaW5pdGlhdGVkIG91dHNpZGUgdGhlIGxvb3BcbiAgICB3aGlsZSAoaSA8IHRhYmxlLmNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIFByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICBpZiAocmVwZWF0Q29sdW1uc01hcC5oYXMoaSkpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xXaWR0aCA9IHRhYmxlLmNvbHVtbnNbaV0ud3JhcHBlZFdpZHRoO1xuICAgICAgICAvLyBUYWtlIGF0IGxlYXN0IG9uZSBjb2x1bW4gZXZlbiBpZiBpdCBkb2Vzbid0IGZpdFxuICAgICAgICBpZiAoZmlyc3QgfHwgcmVtYWluaW5nV2lkdGggPj0gY29sV2lkdGgpIHtcbiAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb2xJbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICBjb2x1bW5zLnB1c2godGFibGUuY29sdW1uc1tpXSk7XG4gICAgICAgICAgICByZW1haW5pbmdXaWR0aCAtPSBjb2xXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHsgY29sSW5kZXhlczogY29sSW5kZXhlcywgY29sdW1uczogY29sdW1ucywgbGFzdEluZGV4OiBpIC0gMSB9O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQWxsQ29sdW1uc0NhbkZpdEluUGFnZShkb2MsIHRhYmxlKSB7XG4gICAgdmFyIGFsbFJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYmxlLmNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGdldENvbHVtbnNDYW5GaXRJblBhZ2UoZG9jLCB0YWJsZSwgeyBzdGFydDogaSB9KTtcbiAgICAgICAgaWYgKHJlc3VsdC5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWxsUmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICBpID0gcmVzdWx0Lmxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWxsUmVzdWx0cztcbn1cblxuZnVuY3Rpb24gZHJhd1RhYmxlKGpzUERGRG9jLCB0YWJsZSkge1xuICAgIHZhciBzZXR0aW5ncyA9IHRhYmxlLnNldHRpbmdzO1xuICAgIHZhciBzdGFydFkgPSBzZXR0aW5ncy5zdGFydFk7XG4gICAgdmFyIG1hcmdpbiA9IHNldHRpbmdzLm1hcmdpbjtcbiAgICB2YXIgY3Vyc29yID0geyB4OiBtYXJnaW4ubGVmdCwgeTogc3RhcnRZIH07XG4gICAgdmFyIHNlY3Rpb25zSGVpZ2h0ID0gdGFibGUuZ2V0SGVhZEhlaWdodCh0YWJsZS5jb2x1bW5zKSArIHRhYmxlLmdldEZvb3RIZWlnaHQodGFibGUuY29sdW1ucyk7XG4gICAgdmFyIG1pblRhYmxlQm90dG9tUG9zID0gc3RhcnRZICsgbWFyZ2luLmJvdHRvbSArIHNlY3Rpb25zSGVpZ2h0O1xuICAgIGlmIChzZXR0aW5ncy5wYWdlQnJlYWsgPT09ICdhdm9pZCcpIHtcbiAgICAgICAgdmFyIHJvd3MgPSB0YWJsZS5ib2R5O1xuICAgICAgICB2YXIgdGFibGVIZWlnaHQgPSByb3dzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCByb3cpIHsgcmV0dXJuIGFjYyArIHJvdy5oZWlnaHQ7IH0sIDApO1xuICAgICAgICBtaW5UYWJsZUJvdHRvbVBvcyArPSB0YWJsZUhlaWdodDtcbiAgICB9XG4gICAgdmFyIGRvYyA9IG5ldyBEb2NIYW5kbGVyKGpzUERGRG9jKTtcbiAgICBpZiAoc2V0dGluZ3MucGFnZUJyZWFrID09PSAnYWx3YXlzJyB8fFxuICAgICAgICAoc2V0dGluZ3Muc3RhcnRZICE9IG51bGwgJiYgbWluVGFibGVCb3R0b21Qb3MgPiBkb2MucGFnZVNpemUoKS5oZWlnaHQpKSB7XG4gICAgICAgIG5leHRQYWdlKGRvYyk7XG4gICAgICAgIGN1cnNvci55ID0gbWFyZ2luLnRvcDtcbiAgICB9XG4gICAgdGFibGUuY2FsbFdpbGxEcmF3UGFnZUhvb2tzKGRvYywgY3Vyc29yKTtcbiAgICB2YXIgc3RhcnRQb3MgPSBhc3NpZ24oe30sIGN1cnNvcik7XG4gICAgdGFibGUuc3RhcnRQYWdlTnVtYmVyID0gZG9jLnBhZ2VOdW1iZXIoKTtcbiAgICBpZiAoc2V0dGluZ3MuaG9yaXpvbnRhbFBhZ2VCcmVhaykge1xuICAgICAgICAvLyBtYW5hZ2VkIGZsb3cgZm9yIHNwbGl0IGNvbHVtbnNcbiAgICAgICAgcHJpbnRUYWJsZVdpdGhIb3Jpem9udGFsUGFnZUJyZWFrKGRvYywgdGFibGUsIHN0YXJ0UG9zLCBjdXJzb3IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gbm9ybWFsIGZsb3dcbiAgICAgICAgZG9jLmFwcGx5U3R5bGVzKGRvYy51c2VyU3R5bGVzKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLnNob3dIZWFkID09PSAnZmlyc3RQYWdlJyB8fFxuICAgICAgICAgICAgc2V0dGluZ3Muc2hvd0hlYWQgPT09ICdldmVyeVBhZ2UnKSB7XG4gICAgICAgICAgICB0YWJsZS5oZWFkLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmludFJvdyhkb2MsIHRhYmxlLCByb3csIGN1cnNvciwgdGFibGUuY29sdW1ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkb2MuYXBwbHlTdHlsZXMoZG9jLnVzZXJTdHlsZXMpO1xuICAgICAgICB0YWJsZS5ib2R5LmZvckVhY2goZnVuY3Rpb24gKHJvdywgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBpc0xhc3RSb3cgPSBpbmRleCA9PT0gdGFibGUuYm9keS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgcHJpbnRGdWxsUm93KGRvYywgdGFibGUsIHJvdywgaXNMYXN0Um93LCBzdGFydFBvcywgY3Vyc29yLCB0YWJsZS5jb2x1bW5zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvYy5hcHBseVN0eWxlcyhkb2MudXNlclN0eWxlcyk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5zaG93Rm9vdCA9PT0gJ2xhc3RQYWdlJyB8fCBzZXR0aW5ncy5zaG93Rm9vdCA9PT0gJ2V2ZXJ5UGFnZScpIHtcbiAgICAgICAgICAgIHRhYmxlLmZvb3QuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByaW50Um93KGRvYywgdGFibGUsIHJvdywgY3Vyc29yLCB0YWJsZS5jb2x1bW5zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFRhYmxlQm9yZGVyKGRvYywgdGFibGUsIHN0YXJ0UG9zLCBjdXJzb3IpO1xuICAgIHRhYmxlLmNhbGxFbmRQYWdlSG9va3MoZG9jLCBjdXJzb3IpO1xuICAgIHRhYmxlLmZpbmFsWSA9IGN1cnNvci55O1xuICAgIGpzUERGRG9jLmxhc3RBdXRvVGFibGUgPSB0YWJsZTtcbiAgICBkb2MuYXBwbHlTdHlsZXMoZG9jLnVzZXJTdHlsZXMpO1xufVxuZnVuY3Rpb24gcHJpbnRUYWJsZVdpdGhIb3Jpem9udGFsUGFnZUJyZWFrKGRvYywgdGFibGUsIHN0YXJ0UG9zLCBjdXJzb3IpIHtcbiAgICAvLyBjYWxjdWxhdGUgd2lkdGggb2YgY29sdW1ucyBhbmQgcmVuZGVyIG9ubHkgdGhvc2Ugd2hpY2ggY2FuIGZpdCBpbnRvIHBhZ2VcbiAgICB2YXIgYWxsQ29sdW1uc0NhbkZpdFJlc3VsdCA9IGNhbGN1bGF0ZUFsbENvbHVtbnNDYW5GaXRJblBhZ2UoZG9jLCB0YWJsZSk7XG4gICAgdmFyIHNldHRpbmdzID0gdGFibGUuc2V0dGluZ3M7XG4gICAgaWYgKHNldHRpbmdzLmhvcml6b250YWxQYWdlQnJlYWtCZWhhdmlvdXIgPT09ICdhZnRlckFsbFJvd3MnKSB7XG4gICAgICAgIGFsbENvbHVtbnNDYW5GaXRSZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAoY29sc0FuZEluZGV4ZXMsIGluZGV4KSB7XG4gICAgICAgICAgICBkb2MuYXBwbHlTdHlsZXMoZG9jLnVzZXJTdHlsZXMpO1xuICAgICAgICAgICAgLy8gYWRkIHBhZ2UgdG8gcHJpbnQgbmV4dCBjb2x1bW5zIGluIG5ldyBwYWdlXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBhZGRpbmcgYSBwYWdlIGhlcmUsIG1ha2Ugc3VyZSBub3QgdG8gcHJpbnQgdGhlIGZvb3RlcnNcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXkgd2VyZSBhbHJlYWR5IHByaW50ZWQgYmVmb3JlIG9uIHRoaXMgc2FtZSBsb29wXG4gICAgICAgICAgICAgICAgYWRkUGFnZShkb2MsIHRhYmxlLCBzdGFydFBvcywgY3Vyc29yLCBjb2xzQW5kSW5kZXhlcy5jb2x1bW5zLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHByaW50IGhlYWQgZm9yIHNlbGVjdGVkIGNvbHVtbnNcbiAgICAgICAgICAgICAgICBwcmludEhlYWQoZG9jLCB0YWJsZSwgY3Vyc29yLCBjb2xzQW5kSW5kZXhlcy5jb2x1bW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByaW50IGJvZHkgJiBmb290ZXIgZm9yIHNlbGVjdGVkIGNvbHVtbnNcbiAgICAgICAgICAgIHByaW50Qm9keShkb2MsIHRhYmxlLCBzdGFydFBvcywgY3Vyc29yLCBjb2xzQW5kSW5kZXhlcy5jb2x1bW5zKTtcbiAgICAgICAgICAgIHByaW50Rm9vdChkb2MsIHRhYmxlLCBjdXJzb3IsIGNvbHNBbmRJbmRleGVzLmNvbHVtbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBsYXN0Um93SW5kZXhPZkxhc3RQYWdlXzEgPSAtMTtcbiAgICAgICAgdmFyIGZpcnN0Q29sdW1uc1RvRml0UmVzdWx0ID0gYWxsQ29sdW1uc0NhbkZpdFJlc3VsdFswXTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBQcmludCB0aGUgZmlyc3QgY29sdW1ucywgdGFraW5nIG5vdGUgb2YgdGhlIGxhc3Qgcm93IHByaW50ZWRcbiAgICAgICAgICAgIHZhciBsYXN0UHJpbnRlZFJvd0luZGV4ID0gbGFzdFJvd0luZGV4T2ZMYXN0UGFnZV8xO1xuICAgICAgICAgICAgaWYgKGZpcnN0Q29sdW1uc1RvRml0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgZG9jLmFwcGx5U3R5bGVzKGRvYy51c2VyU3R5bGVzKTtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RDb2x1bW5zVG9GaXQgPSBmaXJzdENvbHVtbnNUb0ZpdFJlc3VsdC5jb2x1bW5zO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0Um93SW5kZXhPZkxhc3RQYWdlXzEgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGFkZGluZyBhIHBhZ2UgaGVyZSwgbWFrZSBzdXJlIG5vdCB0byBwcmludCB0aGUgZm9vdGVyc1xuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXkgd2VyZSBhbHJlYWR5IHByaW50ZWQgYmVmb3JlIG9uIHRoaXMgc2FtZSBsb29wXG4gICAgICAgICAgICAgICAgICAgIGFkZFBhZ2UoZG9jLCB0YWJsZSwgc3RhcnRQb3MsIGN1cnNvciwgZmlyc3RDb2x1bW5zVG9GaXQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRIZWFkKGRvYywgdGFibGUsIGN1cnNvciwgZmlyc3RDb2x1bW5zVG9GaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0UHJpbnRlZFJvd0luZGV4ID0gcHJpbnRCb2R5V2l0aG91dFBhZ2VCcmVha3MoZG9jLCB0YWJsZSwgbGFzdFJvd0luZGV4T2ZMYXN0UGFnZV8xICsgMSwgY3Vyc29yLCBmaXJzdENvbHVtbnNUb0ZpdCk7XG4gICAgICAgICAgICAgICAgcHJpbnRGb290KGRvYywgdGFibGUsIGN1cnNvciwgZmlyc3RDb2x1bW5zVG9GaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaG93IG1hbnkgcm93cyB3ZXJlIHByaW50ZWQsIHNvIHRoYXQgdGhlIG5leHQgY29sdW1ucyB3b3VsZCBub3QgcHJpbnQgbW9yZSByb3dzIHRoYW4gdGhhdFxuICAgICAgICAgICAgdmFyIG1heE51bWJlck9mUm93cyA9IGxhc3RQcmludGVkUm93SW5kZXggLSBsYXN0Um93SW5kZXhPZkxhc3RQYWdlXzE7XG4gICAgICAgICAgICAvLyBQcmludCB0aGUgbmV4dCBjb2x1bW5zLCBuZXZlciBleGNlZGluZyBtYXhOdW1iZXJPZlJvd3NcbiAgICAgICAgICAgIGFsbENvbHVtbnNDYW5GaXRSZXN1bHQuc2xpY2UoMSkuZm9yRWFjaChmdW5jdGlvbiAoY29sc0FuZEluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICBkb2MuYXBwbHlTdHlsZXMoZG9jLnVzZXJTdHlsZXMpO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gYWRkaW5nIGEgcGFnZSBoZXJlLCBtYWtlIHN1cmUgbm90IHRvIHByaW50IHRoZSBmb290ZXJzXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGV5IHdlcmUgYWxyZWFkeSBwcmludGVkIGJlZm9yZSBvbiB0aGlzIHNhbWUgbG9vcFxuICAgICAgICAgICAgICAgIGFkZFBhZ2UoZG9jLCB0YWJsZSwgc3RhcnRQb3MsIGN1cnNvciwgY29sc0FuZEluZGV4ZXMuY29sdW1ucywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcHJpbnRCb2R5V2l0aG91dFBhZ2VCcmVha3MoZG9jLCB0YWJsZSwgbGFzdFJvd0luZGV4T2ZMYXN0UGFnZV8xICsgMSwgY3Vyc29yLCBjb2xzQW5kSW5kZXhlcy5jb2x1bW5zLCBtYXhOdW1iZXJPZlJvd3MpO1xuICAgICAgICAgICAgICAgIHByaW50Rm9vdChkb2MsIHRhYmxlLCBjdXJzb3IsIGNvbHNBbmRJbmRleGVzLmNvbHVtbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsYXN0Um93SW5kZXhPZkxhc3RQYWdlXzEgPSBsYXN0UHJpbnRlZFJvd0luZGV4O1xuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAobGFzdFJvd0luZGV4T2ZMYXN0UGFnZV8xIDwgdGFibGUuYm9keS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBfbG9vcF8xKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwcmludEhlYWQoZG9jLCB0YWJsZSwgY3Vyc29yLCBjb2x1bW5zKSB7XG4gICAgdmFyIHNldHRpbmdzID0gdGFibGUuc2V0dGluZ3M7XG4gICAgZG9jLmFwcGx5U3R5bGVzKGRvYy51c2VyU3R5bGVzKTtcbiAgICBpZiAoc2V0dGluZ3Muc2hvd0hlYWQgPT09ICdmaXJzdFBhZ2UnIHx8IHNldHRpbmdzLnNob3dIZWFkID09PSAnZXZlcnlQYWdlJykge1xuICAgICAgICB0YWJsZS5oZWFkLmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcHJpbnRSb3coZG9jLCB0YWJsZSwgcm93LCBjdXJzb3IsIGNvbHVtbnMpOyB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmludEJvZHkoZG9jLCB0YWJsZSwgc3RhcnRQb3MsIGN1cnNvciwgY29sdW1ucykge1xuICAgIGRvYy5hcHBseVN0eWxlcyhkb2MudXNlclN0eWxlcyk7XG4gICAgdGFibGUuYm9keS5mb3JFYWNoKGZ1bmN0aW9uIChyb3csIGluZGV4KSB7XG4gICAgICAgIHZhciBpc0xhc3RSb3cgPSBpbmRleCA9PT0gdGFibGUuYm9keS5sZW5ndGggLSAxO1xuICAgICAgICBwcmludEZ1bGxSb3coZG9jLCB0YWJsZSwgcm93LCBpc0xhc3RSb3csIHN0YXJ0UG9zLCBjdXJzb3IsIGNvbHVtbnMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJpbnRCb2R5V2l0aG91dFBhZ2VCcmVha3MoZG9jLCB0YWJsZSwgc3RhcnRSb3dJbmRleCwgY3Vyc29yLCBjb2x1bW5zLCBtYXhOdW1iZXJPZlJvd3MpIHtcbiAgICBkb2MuYXBwbHlTdHlsZXMoZG9jLnVzZXJTdHlsZXMpO1xuICAgIG1heE51bWJlck9mUm93cyA9IG1heE51bWJlck9mUm93cyAhPT0gbnVsbCAmJiBtYXhOdW1iZXJPZlJvd3MgIT09IHZvaWQgMCA/IG1heE51bWJlck9mUm93cyA6IHRhYmxlLmJvZHkubGVuZ3RoO1xuICAgIHZhciBlbmRSb3dJbmRleCA9IE1hdGgubWluKHN0YXJ0Um93SW5kZXggKyBtYXhOdW1iZXJPZlJvd3MsIHRhYmxlLmJvZHkubGVuZ3RoKTtcbiAgICB2YXIgbGFzdFByaW50ZWRSb3dJbmRleCA9IC0xO1xuICAgIHRhYmxlLmJvZHkuc2xpY2Uoc3RhcnRSb3dJbmRleCwgZW5kUm93SW5kZXgpLmZvckVhY2goZnVuY3Rpb24gKHJvdywgaW5kZXgpIHtcbiAgICAgICAgdmFyIGlzTGFzdFJvdyA9IHN0YXJ0Um93SW5kZXggKyBpbmRleCA9PT0gdGFibGUuYm9keS5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgcmVtYWluaW5nU3BhY2UgPSBnZXRSZW1haW5pbmdQYWdlU3BhY2UoZG9jLCB0YWJsZSwgaXNMYXN0Um93LCBjdXJzb3IpO1xuICAgICAgICBpZiAocm93LmNhbkVudGlyZVJvd0ZpdChyZW1haW5pbmdTcGFjZSwgY29sdW1ucykpIHtcbiAgICAgICAgICAgIHByaW50Um93KGRvYywgdGFibGUsIHJvdywgY3Vyc29yLCBjb2x1bW5zKTtcbiAgICAgICAgICAgIGxhc3RQcmludGVkUm93SW5kZXggPSBzdGFydFJvd0luZGV4ICsgaW5kZXg7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbGFzdFByaW50ZWRSb3dJbmRleDtcbn1cbmZ1bmN0aW9uIHByaW50Rm9vdChkb2MsIHRhYmxlLCBjdXJzb3IsIGNvbHVtbnMpIHtcbiAgICB2YXIgc2V0dGluZ3MgPSB0YWJsZS5zZXR0aW5ncztcbiAgICBkb2MuYXBwbHlTdHlsZXMoZG9jLnVzZXJTdHlsZXMpO1xuICAgIGlmIChzZXR0aW5ncy5zaG93Rm9vdCA9PT0gJ2xhc3RQYWdlJyB8fCBzZXR0aW5ncy5zaG93Rm9vdCA9PT0gJ2V2ZXJ5UGFnZScpIHtcbiAgICAgICAgdGFibGUuZm9vdC5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHByaW50Um93KGRvYywgdGFibGUsIHJvdywgY3Vyc29yLCBjb2x1bW5zKTsgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UmVtYWluaW5nTGluZUNvdW50KGNlbGwsIHJlbWFpbmluZ1BhZ2VTcGFjZSwgZG9jKSB7XG4gICAgdmFyIGxpbmVIZWlnaHQgPSBkb2MuZ2V0TGluZUhlaWdodChjZWxsLnN0eWxlcy5mb250U2l6ZSk7XG4gICAgdmFyIHZQYWRkaW5nID0gY2VsbC5wYWRkaW5nKCd2ZXJ0aWNhbCcpO1xuICAgIHZhciByZW1haW5pbmdMaW5lcyA9IE1hdGguZmxvb3IoKHJlbWFpbmluZ1BhZ2VTcGFjZSAtIHZQYWRkaW5nKSAvIGxpbmVIZWlnaHQpO1xuICAgIHJldHVybiBNYXRoLm1heCgwLCByZW1haW5pbmdMaW5lcyk7XG59XG5mdW5jdGlvbiBtb2RpZnlSb3dUb0ZpdChyb3csIHJlbWFpbmluZ1BhZ2VTcGFjZSwgdGFibGUsIGRvYykge1xuICAgIHZhciBjZWxscyA9IHt9O1xuICAgIHJvdy5zcGFuc011bHRpcGxlUGFnZXMgPSB0cnVlO1xuICAgIHJvdy5oZWlnaHQgPSAwO1xuICAgIHZhciByb3dIZWlnaHQgPSAwO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0YWJsZS5jb2x1bW5zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY29sdW1uID0gX2FbX2ldO1xuICAgICAgICB2YXIgY2VsbCA9IHJvdy5jZWxsc1tjb2x1bW4uaW5kZXhdO1xuICAgICAgICBpZiAoIWNlbGwpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNlbGwudGV4dCkpIHtcbiAgICAgICAgICAgIGNlbGwudGV4dCA9IFtjZWxsLnRleHRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZW1haW5kZXJDZWxsID0gbmV3IENlbGwoY2VsbC5yYXcsIGNlbGwuc3R5bGVzLCBjZWxsLnNlY3Rpb24pO1xuICAgICAgICByZW1haW5kZXJDZWxsID0gYXNzaWduKHJlbWFpbmRlckNlbGwsIGNlbGwpO1xuICAgICAgICByZW1haW5kZXJDZWxsLnRleHQgPSBbXTtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0xpbmVDb3VudCA9IGdldFJlbWFpbmluZ0xpbmVDb3VudChjZWxsLCByZW1haW5pbmdQYWdlU3BhY2UsIGRvYyk7XG4gICAgICAgIGlmIChjZWxsLnRleHQubGVuZ3RoID4gcmVtYWluaW5nTGluZUNvdW50KSB7XG4gICAgICAgICAgICByZW1haW5kZXJDZWxsLnRleHQgPSBjZWxsLnRleHQuc3BsaWNlKHJlbWFpbmluZ0xpbmVDb3VudCwgY2VsbC50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjYWxlRmFjdG9yID0gZG9jLnNjYWxlRmFjdG9yKCk7XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0RmFjdG9yID0gZG9jLmdldExpbmVIZWlnaHRGYWN0b3IoKTtcbiAgICAgICAgY2VsbC5jb250ZW50SGVpZ2h0ID0gY2VsbC5nZXRDb250ZW50SGVpZ2h0KHNjYWxlRmFjdG9yLCBsaW5lSGVpZ2h0RmFjdG9yKTtcbiAgICAgICAgaWYgKGNlbGwuY29udGVudEhlaWdodCA+PSByZW1haW5pbmdQYWdlU3BhY2UpIHtcbiAgICAgICAgICAgIGNlbGwuY29udGVudEhlaWdodCA9IHJlbWFpbmluZ1BhZ2VTcGFjZTtcbiAgICAgICAgICAgIHJlbWFpbmRlckNlbGwuc3R5bGVzLm1pbkNlbGxIZWlnaHQgLT0gcmVtYWluaW5nUGFnZVNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjZWxsLmNvbnRlbnRIZWlnaHQgPiByb3cuaGVpZ2h0KSB7XG4gICAgICAgICAgICByb3cuaGVpZ2h0ID0gY2VsbC5jb250ZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJlbWFpbmRlckNlbGwuY29udGVudEhlaWdodCA9IHJlbWFpbmRlckNlbGwuZ2V0Q29udGVudEhlaWdodChzY2FsZUZhY3RvciwgbGluZUhlaWdodEZhY3Rvcik7XG4gICAgICAgIGlmIChyZW1haW5kZXJDZWxsLmNvbnRlbnRIZWlnaHQgPiByb3dIZWlnaHQpIHtcbiAgICAgICAgICAgIHJvd0hlaWdodCA9IHJlbWFpbmRlckNlbGwuY29udGVudEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjZWxsc1tjb2x1bW4uaW5kZXhdID0gcmVtYWluZGVyQ2VsbDtcbiAgICB9XG4gICAgdmFyIHJlbWFpbmRlclJvdyA9IG5ldyBSb3cocm93LnJhdywgLTEsIHJvdy5zZWN0aW9uLCBjZWxscywgdHJ1ZSk7XG4gICAgcmVtYWluZGVyUm93LmhlaWdodCA9IHJvd0hlaWdodDtcbiAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGFibGUuY29sdW1uczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IF9jW19iXTtcbiAgICAgICAgdmFyIHJlbWFpbmRlckNlbGwgPSByZW1haW5kZXJSb3cuY2VsbHNbY29sdW1uLmluZGV4XTtcbiAgICAgICAgaWYgKHJlbWFpbmRlckNlbGwpIHtcbiAgICAgICAgICAgIHJlbWFpbmRlckNlbGwuaGVpZ2h0ID0gcmVtYWluZGVyUm93LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2VsbCA9IHJvdy5jZWxsc1tjb2x1bW4uaW5kZXhdO1xuICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgY2VsbC5oZWlnaHQgPSByb3cuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW1haW5kZXJSb3c7XG59XG5mdW5jdGlvbiBzaG91bGRQcmludE9uQ3VycmVudFBhZ2UoZG9jLCByb3csIHJlbWFpbmluZ1BhZ2VTcGFjZSwgdGFibGUpIHtcbiAgICB2YXIgcGFnZUhlaWdodCA9IGRvYy5wYWdlU2l6ZSgpLmhlaWdodDtcbiAgICB2YXIgbWFyZ2luID0gdGFibGUuc2V0dGluZ3MubWFyZ2luO1xuICAgIHZhciBtYXJnaW5IZWlnaHQgPSBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbTtcbiAgICB2YXIgbWF4Um93SGVpZ2h0ID0gcGFnZUhlaWdodCAtIG1hcmdpbkhlaWdodDtcbiAgICBpZiAocm93LnNlY3Rpb24gPT09ICdib2R5Jykge1xuICAgICAgICAvLyBTaG91bGQgYWxzbyB0YWtlIGludG8gYWNjb3VudCB0aGF0IGhlYWQgYW5kIGZvb3QgaXMgbm90XG4gICAgICAgIC8vIG9uIGV2ZXJ5IHBhZ2Ugd2l0aCBzb21lIHNldHRpbmdzXG4gICAgICAgIG1heFJvd0hlaWdodCAtPVxuICAgICAgICAgICAgdGFibGUuZ2V0SGVhZEhlaWdodCh0YWJsZS5jb2x1bW5zKSArIHRhYmxlLmdldEZvb3RIZWlnaHQodGFibGUuY29sdW1ucyk7XG4gICAgfVxuICAgIHZhciBtaW5Sb3dIZWlnaHQgPSByb3cuZ2V0TWluaW11bVJvd0hlaWdodCh0YWJsZS5jb2x1bW5zLCBkb2MpO1xuICAgIHZhciBtaW5Sb3dGaXRzID0gbWluUm93SGVpZ2h0IDwgcmVtYWluaW5nUGFnZVNwYWNlO1xuICAgIGlmIChtaW5Sb3dIZWlnaHQgPiBtYXhSb3dIZWlnaHQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIldpbGwgbm90IGJlIGFibGUgdG8gcHJpbnQgcm93IFwiLmNvbmNhdChyb3cuaW5kZXgsIFwiIGNvcnJlY3RseSBzaW5jZSBpdCdzIG1pbmltdW0gaGVpZ2h0IGlzIGxhcmdlciB0aGFuIHBhZ2UgaGVpZ2h0XCIpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghbWluUm93Rml0cykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciByb3dIYXNSb3dTcGFuQ2VsbCA9IHJvdy5oYXNSb3dTcGFuKHRhYmxlLmNvbHVtbnMpO1xuICAgIHZhciByb3dIaWdoZXJUaGFuUGFnZSA9IHJvdy5nZXRNYXhDZWxsSGVpZ2h0KHRhYmxlLmNvbHVtbnMpID4gbWF4Um93SGVpZ2h0O1xuICAgIGlmIChyb3dIaWdoZXJUaGFuUGFnZSkge1xuICAgICAgICBpZiAocm93SGFzUm93U3BhbkNlbGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUaGUgY29udGVudCBvZiByb3cgXCIuY29uY2F0KHJvdy5pbmRleCwgXCIgd2lsbCBub3QgYmUgZHJhd24gY29ycmVjdGx5IHNpbmNlIGRyYXdpbmcgcm93cyB3aXRoIGEgaGVpZ2h0IGxhcmdlciB0aGFuIHRoZSBwYWdlIGhlaWdodCBhbmQgaGFzIGNlbGxzIHdpdGggcm93c3BhbnMgaXMgbm90IHN1cHBvcnRlZC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocm93SGFzUm93U3BhbkNlbGwpIHtcbiAgICAgICAgLy8gQ3VycmVudGx5IGEgbmV3IHBhZ2UgaXMgcmVxdWlyZWQgd2hlbmV2ZXIgYSByb3dzcGFuIHJvdyBkb24ndCBmaXQgYSBwYWdlLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0YWJsZS5zZXR0aW5ncy5yb3dQYWdlQnJlYWsgPT09ICdhdm9pZCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJbiBhbGwgb3RoZXIgY2FzZXMgcHJpbnQgdGhlIHJvdyBvbiBjdXJyZW50IHBhZ2VcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHByaW50RnVsbFJvdyhkb2MsIHRhYmxlLCByb3csIGlzTGFzdFJvdywgc3RhcnRQb3MsIGN1cnNvciwgY29sdW1ucykge1xuICAgIHZhciByZW1haW5pbmdTcGFjZSA9IGdldFJlbWFpbmluZ1BhZ2VTcGFjZShkb2MsIHRhYmxlLCBpc0xhc3RSb3csIGN1cnNvcik7XG4gICAgaWYgKHJvdy5jYW5FbnRpcmVSb3dGaXQocmVtYWluaW5nU3BhY2UsIGNvbHVtbnMpKSB7XG4gICAgICAgIC8vIFRoZSByb3cgZml0cyBpbiB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgIHByaW50Um93KGRvYywgdGFibGUsIHJvdywgY3Vyc29yLCBjb2x1bW5zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2hvdWxkUHJpbnRPbkN1cnJlbnRQYWdlKGRvYywgcm93LCByZW1haW5pbmdTcGFjZSwgdGFibGUpKSB7XG4gICAgICAgIC8vIFRoZSByb3cgZ2V0cyBzcGxpdCBpbiB0d28gaGVyZSwgZWFjaCBwaWVjZSBpbiBvbmUgcGFnZVxuICAgICAgICB2YXIgcmVtYWluZGVyUm93ID0gbW9kaWZ5Um93VG9GaXQocm93LCByZW1haW5pbmdTcGFjZSwgdGFibGUsIGRvYyk7XG4gICAgICAgIHByaW50Um93KGRvYywgdGFibGUsIHJvdywgY3Vyc29yLCBjb2x1bW5zKTtcbiAgICAgICAgYWRkUGFnZShkb2MsIHRhYmxlLCBzdGFydFBvcywgY3Vyc29yLCBjb2x1bW5zKTtcbiAgICAgICAgcHJpbnRGdWxsUm93KGRvYywgdGFibGUsIHJlbWFpbmRlclJvdywgaXNMYXN0Um93LCBzdGFydFBvcywgY3Vyc29yLCBjb2x1bW5zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoZSByb3cgZ2V0IHByaW50ZWQgZW50aXJlbGx5IG9uIHRoZSBuZXh0IHBhZ2VcbiAgICAgICAgYWRkUGFnZShkb2MsIHRhYmxlLCBzdGFydFBvcywgY3Vyc29yLCBjb2x1bW5zKTtcbiAgICAgICAgcHJpbnRGdWxsUm93KGRvYywgdGFibGUsIHJvdywgaXNMYXN0Um93LCBzdGFydFBvcywgY3Vyc29yLCBjb2x1bW5zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmludFJvdyhkb2MsIHRhYmxlLCByb3csIGN1cnNvciwgY29sdW1ucykge1xuICAgIGN1cnNvci54ID0gdGFibGUuc2V0dGluZ3MubWFyZ2luLmxlZnQ7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBjb2x1bW5zXzEgPSBjb2x1bW5zOyBfaSA8IGNvbHVtbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IGNvbHVtbnNfMVtfaV07XG4gICAgICAgIHZhciBjZWxsID0gcm93LmNlbGxzW2NvbHVtbi5pbmRleF07XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgICAgY3Vyc29yLnggKz0gY29sdW1uLndpZHRoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZG9jLmFwcGx5U3R5bGVzKGNlbGwuc3R5bGVzKTtcbiAgICAgICAgY2VsbC54ID0gY3Vyc29yLng7XG4gICAgICAgIGNlbGwueSA9IGN1cnNvci55O1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGFibGUuY2FsbENlbGxIb29rcyhkb2MsIHRhYmxlLmhvb2tzLndpbGxEcmF3Q2VsbCwgY2VsbCwgcm93LCBjb2x1bW4sIGN1cnNvcik7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjdXJzb3IueCArPSBjb2x1bW4ud2lkdGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBkcmF3Q2VsbFJlY3QoZG9jLCBjZWxsLCBjdXJzb3IpO1xuICAgICAgICB2YXIgdGV4dFBvcyA9IGNlbGwuZ2V0VGV4dFBvcygpO1xuICAgICAgICBhdXRvVGFibGVUZXh0KGNlbGwudGV4dCwgdGV4dFBvcy54LCB0ZXh0UG9zLnksIHtcbiAgICAgICAgICAgIGhhbGlnbjogY2VsbC5zdHlsZXMuaGFsaWduLFxuICAgICAgICAgICAgdmFsaWduOiBjZWxsLnN0eWxlcy52YWxpZ24sXG4gICAgICAgICAgICBtYXhXaWR0aDogTWF0aC5jZWlsKGNlbGwud2lkdGggLSBjZWxsLnBhZGRpbmcoJ2xlZnQnKSAtIGNlbGwucGFkZGluZygncmlnaHQnKSksXG4gICAgICAgIH0sIGRvYy5nZXREb2N1bWVudCgpKTtcbiAgICAgICAgdGFibGUuY2FsbENlbGxIb29rcyhkb2MsIHRhYmxlLmhvb2tzLmRpZERyYXdDZWxsLCBjZWxsLCByb3csIGNvbHVtbiwgY3Vyc29yKTtcbiAgICAgICAgY3Vyc29yLnggKz0gY29sdW1uLndpZHRoO1xuICAgIH1cbiAgICBjdXJzb3IueSArPSByb3cuaGVpZ2h0O1xufVxuZnVuY3Rpb24gZHJhd0NlbGxSZWN0KGRvYywgY2VsbCwgY3Vyc29yKSB7XG4gICAgdmFyIGNlbGxTdHlsZXMgPSBjZWxsLnN0eWxlcztcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2ltb25iZW5ndHNzb24vanNQREYtQXV0b1RhYmxlL2lzc3Vlcy83NzRcbiAgICAvLyBUT0RPICh2NCk6IGJldHRlciBzb2x1dGlvbj9cbiAgICBkb2MuZ2V0RG9jdW1lbnQoKS5zZXRGaWxsQ29sb3IoZG9jLmdldERvY3VtZW50KCkuZ2V0RmlsbENvbG9yKCkpO1xuICAgIGlmICh0eXBlb2YgY2VsbFN0eWxlcy5saW5lV2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIERyYXcgY2VsbCBiYWNrZ3JvdW5kIHdpdGggbm9ybWFsIGJvcmRlcnNcbiAgICAgICAgdmFyIGZpbGxTdHlsZSA9IGdldEZpbGxTdHlsZShjZWxsU3R5bGVzLmxpbmVXaWR0aCwgY2VsbFN0eWxlcy5maWxsQ29sb3IpO1xuICAgICAgICBpZiAoZmlsbFN0eWxlKSB7XG4gICAgICAgICAgICBkb2MucmVjdChjZWxsLngsIGN1cnNvci55LCBjZWxsLndpZHRoLCBjZWxsLmhlaWdodCwgZmlsbFN0eWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgY2VsbFN0eWxlcy5saW5lV2lkdGggPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIERyYXcgY2VsbCBiYWNrZ3JvdW5kXG4gICAgICAgIGlmIChjZWxsU3R5bGVzLmZpbGxDb2xvcikge1xuICAgICAgICAgICAgZG9jLnJlY3QoY2VsbC54LCBjdXJzb3IueSwgY2VsbC53aWR0aCwgY2VsbC5oZWlnaHQsICdGJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRHJhdyBjZWxsIGluZGl2aWR1YWwgYm9yZGVyc1xuICAgICAgICBkcmF3Q2VsbEJvcmRlcnMoZG9jLCBjZWxsLCBjdXJzb3IsIGNlbGxTdHlsZXMubGluZVdpZHRoKTtcbiAgICB9XG59XG4vKipcbiAqIERyYXcgYWxsIHNwZWNpZmllZCBib3JkZXJzLiBCb3JkZXJzIGFyZSBjZW50ZXJlZCBvbiBjZWxsJ3MgZWRnZSBhbmQgbGVuZ3RoZW5lZFxuICogdG8gb3ZlcmxhcCB3aXRoIG5laWdoYm91cnMgdG8gY3JlYXRlIHNoYXJwIGNvcm5lcnMuXG4gKiBAcGFyYW0gZG9jXG4gKiBAcGFyYW0gY2VsbFxuICogQHBhcmFtIGN1cnNvclxuICogQHBhcmFtIGZpbGxDb2xvclxuICogQHBhcmFtIGxpbmVXaWR0aFxuICovXG5mdW5jdGlvbiBkcmF3Q2VsbEJvcmRlcnMoZG9jLCBjZWxsLCBjdXJzb3IsIGxpbmVXaWR0aCkge1xuICAgIHZhciB4MSwgeTEsIHgyLCB5MjtcbiAgICBpZiAobGluZVdpZHRoLnRvcCkge1xuICAgICAgICB4MSA9IGN1cnNvci54O1xuICAgICAgICB5MSA9IGN1cnNvci55O1xuICAgICAgICB4MiA9IGN1cnNvci54ICsgY2VsbC53aWR0aDtcbiAgICAgICAgeTIgPSBjdXJzb3IueTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aC5yaWdodCkge1xuICAgICAgICAgICAgeDIgKz0gMC41ICogbGluZVdpZHRoLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lV2lkdGgubGVmdCkge1xuICAgICAgICAgICAgeDEgLT0gMC41ICogbGluZVdpZHRoLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZHJhd0xpbmUobGluZVdpZHRoLnRvcCwgeDEsIHkxLCB4MiwgeTIpO1xuICAgIH1cbiAgICBpZiAobGluZVdpZHRoLmJvdHRvbSkge1xuICAgICAgICB4MSA9IGN1cnNvci54O1xuICAgICAgICB5MSA9IGN1cnNvci55ICsgY2VsbC5oZWlnaHQ7XG4gICAgICAgIHgyID0gY3Vyc29yLnggKyBjZWxsLndpZHRoO1xuICAgICAgICB5MiA9IGN1cnNvci55ICsgY2VsbC5oZWlnaHQ7XG4gICAgICAgIGlmIChsaW5lV2lkdGgucmlnaHQpIHtcbiAgICAgICAgICAgIHgyICs9IDAuNSAqIGxpbmVXaWR0aC5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVdpZHRoLmxlZnQpIHtcbiAgICAgICAgICAgIHgxIC09IDAuNSAqIGxpbmVXaWR0aC5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGRyYXdMaW5lKGxpbmVXaWR0aC5ib3R0b20sIHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9XG4gICAgaWYgKGxpbmVXaWR0aC5sZWZ0KSB7XG4gICAgICAgIHgxID0gY3Vyc29yLng7XG4gICAgICAgIHkxID0gY3Vyc29yLnk7XG4gICAgICAgIHgyID0gY3Vyc29yLng7XG4gICAgICAgIHkyID0gY3Vyc29yLnkgKyBjZWxsLmhlaWdodDtcbiAgICAgICAgaWYgKGxpbmVXaWR0aC50b3ApIHtcbiAgICAgICAgICAgIHkxIC09IDAuNSAqIGxpbmVXaWR0aC50b3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVXaWR0aC5ib3R0b20pIHtcbiAgICAgICAgICAgIHkyICs9IDAuNSAqIGxpbmVXaWR0aC5ib3R0b207XG4gICAgICAgIH1cbiAgICAgICAgZHJhd0xpbmUobGluZVdpZHRoLmxlZnQsIHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9XG4gICAgaWYgKGxpbmVXaWR0aC5yaWdodCkge1xuICAgICAgICB4MSA9IGN1cnNvci54ICsgY2VsbC53aWR0aDtcbiAgICAgICAgeTEgPSBjdXJzb3IueTtcbiAgICAgICAgeDIgPSBjdXJzb3IueCArIGNlbGwud2lkdGg7XG4gICAgICAgIHkyID0gY3Vyc29yLnkgKyBjZWxsLmhlaWdodDtcbiAgICAgICAgaWYgKGxpbmVXaWR0aC50b3ApIHtcbiAgICAgICAgICAgIHkxIC09IDAuNSAqIGxpbmVXaWR0aC50b3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVXaWR0aC5ib3R0b20pIHtcbiAgICAgICAgICAgIHkyICs9IDAuNSAqIGxpbmVXaWR0aC5ib3R0b207XG4gICAgICAgIH1cbiAgICAgICAgZHJhd0xpbmUobGluZVdpZHRoLnJpZ2h0LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyYXdMaW5lKHdpZHRoLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICBkb2MuZ2V0RG9jdW1lbnQoKS5zZXRMaW5lV2lkdGgod2lkdGgpO1xuICAgICAgICBkb2MuZ2V0RG9jdW1lbnQoKS5saW5lKHgxLCB5MSwgeDIsIHkyLCAnUycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFJlbWFpbmluZ1BhZ2VTcGFjZShkb2MsIHRhYmxlLCBpc0xhc3RSb3csIGN1cnNvcikge1xuICAgIHZhciBib3R0b21Db250ZW50SGVpZ2h0ID0gdGFibGUuc2V0dGluZ3MubWFyZ2luLmJvdHRvbTtcbiAgICB2YXIgc2hvd0Zvb3QgPSB0YWJsZS5zZXR0aW5ncy5zaG93Rm9vdDtcbiAgICBpZiAoc2hvd0Zvb3QgPT09ICdldmVyeVBhZ2UnIHx8IChzaG93Rm9vdCA9PT0gJ2xhc3RQYWdlJyAmJiBpc0xhc3RSb3cpKSB7XG4gICAgICAgIGJvdHRvbUNvbnRlbnRIZWlnaHQgKz0gdGFibGUuZ2V0Rm9vdEhlaWdodCh0YWJsZS5jb2x1bW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvYy5wYWdlU2l6ZSgpLmhlaWdodCAtIGN1cnNvci55IC0gYm90dG9tQ29udGVudEhlaWdodDtcbn1cbmZ1bmN0aW9uIGFkZFBhZ2UoZG9jLCB0YWJsZSwgc3RhcnRQb3MsIGN1cnNvciwgY29sdW1ucywgc3VwcHJlc3NGb290ZXIpIHtcbiAgICBpZiAoY29sdW1ucyA9PT0gdm9pZCAwKSB7IGNvbHVtbnMgPSBbXTsgfVxuICAgIGlmIChzdXBwcmVzc0Zvb3RlciA9PT0gdm9pZCAwKSB7IHN1cHByZXNzRm9vdGVyID0gZmFsc2U7IH1cbiAgICBkb2MuYXBwbHlTdHlsZXMoZG9jLnVzZXJTdHlsZXMpO1xuICAgIGlmICh0YWJsZS5zZXR0aW5ncy5zaG93Rm9vdCA9PT0gJ2V2ZXJ5UGFnZScgJiYgIXN1cHByZXNzRm9vdGVyKSB7XG4gICAgICAgIHRhYmxlLmZvb3QuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7IHJldHVybiBwcmludFJvdyhkb2MsIHRhYmxlLCByb3csIGN1cnNvciwgY29sdW1ucyk7IH0pO1xuICAgIH1cbiAgICAvLyBBZGQgdXNlciBjb250ZW50IGp1c3QgYmVmb3JlIGFkZGluZyBuZXcgcGFnZSBlbnN1cmUgaXQgd2lsbFxuICAgIC8vIGJlIGRyYXduIGFib3ZlIG90aGVyIHRoaW5ncyBvbiB0aGUgcGFnZVxuICAgIHRhYmxlLmNhbGxFbmRQYWdlSG9va3MoZG9jLCBjdXJzb3IpO1xuICAgIHZhciBtYXJnaW4gPSB0YWJsZS5zZXR0aW5ncy5tYXJnaW47XG4gICAgYWRkVGFibGVCb3JkZXIoZG9jLCB0YWJsZSwgc3RhcnRQb3MsIGN1cnNvcik7XG4gICAgbmV4dFBhZ2UoZG9jKTtcbiAgICB0YWJsZS5wYWdlTnVtYmVyKys7XG4gICAgY3Vyc29yLnggPSBtYXJnaW4ubGVmdDtcbiAgICBjdXJzb3IueSA9IG1hcmdpbi50b3A7XG4gICAgc3RhcnRQb3MueSA9IG1hcmdpbi50b3A7XG4gICAgLy8gY2FsbCBkaWRBZGRQYWdlIGhvb2tzIGJlZm9yZSBhbnkgY29udGVudCBpcyBhZGRlZCB0byB0aGUgcGFnZVxuICAgIHRhYmxlLmNhbGxXaWxsRHJhd1BhZ2VIb29rcyhkb2MsIGN1cnNvcik7XG4gICAgaWYgKHRhYmxlLnNldHRpbmdzLnNob3dIZWFkID09PSAnZXZlcnlQYWdlJykge1xuICAgICAgICB0YWJsZS5oZWFkLmZvckVhY2goZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcHJpbnRSb3coZG9jLCB0YWJsZSwgcm93LCBjdXJzb3IsIGNvbHVtbnMpOyB9KTtcbiAgICAgICAgZG9jLmFwcGx5U3R5bGVzKGRvYy51c2VyU3R5bGVzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXh0UGFnZShkb2MpIHtcbiAgICB2YXIgY3VycmVudCA9IGRvYy5wYWdlTnVtYmVyKCk7XG4gICAgZG9jLnNldFBhZ2UoY3VycmVudCArIDEpO1xuICAgIHZhciBuZXdDdXJyZW50ID0gZG9jLnBhZ2VOdW1iZXIoKTtcbiAgICBpZiAobmV3Q3VycmVudCA9PT0gY3VycmVudCkge1xuICAgICAgICBkb2MuYWRkUGFnZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhcHBseVBsdWdpbihqc1BERikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAganNQREYuQVBJLmF1dG9UYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBpbnB1dCA9IHBhcnNlSW5wdXQodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHZhciB0YWJsZSA9IGNyZWF0ZVRhYmxlKHRoaXMsIGlucHV0KTtcbiAgICAgICAgZHJhd1RhYmxlKHRoaXMsIHRhYmxlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBBc3NpZ24gZmFsc2UgdG8gZW5hYmxlIGBkb2MubGFzdEF1dG9UYWJsZS5maW5hbFkgfHwgNDBgIHN1Z2FyXG4gICAganNQREYuQVBJLmxhc3RBdXRvVGFibGUgPSBmYWxzZTtcbiAgICBqc1BERi5BUEkuYXV0b1RhYmxlVGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCB4LCB5LCBzdHlsZXMpIHtcbiAgICAgICAgYXV0b1RhYmxlVGV4dCh0ZXh0LCB4LCB5LCBzdHlsZXMsIHRoaXMpO1xuICAgIH07XG4gICAganNQREYuQVBJLmF1dG9UYWJsZVNldERlZmF1bHRzID0gZnVuY3Rpb24gKGRlZmF1bHRzKSB7XG4gICAgICAgIERvY0hhbmRsZXIuc2V0RGVmYXVsdHMoZGVmYXVsdHMsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGpzUERGLmF1dG9UYWJsZVNldERlZmF1bHRzID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBkb2MpIHtcbiAgICAgICAgRG9jSGFuZGxlci5zZXREZWZhdWx0cyhkZWZhdWx0cywgZG9jKTtcbiAgICB9O1xuICAgIGpzUERGLkFQSS5hdXRvVGFibGVIdG1sVG9Kc29uID0gZnVuY3Rpb24gKHRhYmxlRWxlbSwgaW5jbHVkZUhpZGRlbkVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGluY2x1ZGVIaWRkZW5FbGVtZW50cyA9PT0gdm9pZCAwKSB7IGluY2x1ZGVIaWRkZW5FbGVtZW50cyA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IHJ1biBhdXRvVGFibGVIdG1sVG9Kc29uIGluIG5vbiBicm93c2VyIGVudmlyb25tZW50Jyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG9jID0gbmV3IERvY0hhbmRsZXIodGhpcyk7XG4gICAgICAgIHZhciBfYiA9IHBhcnNlSHRtbChkb2MsIHRhYmxlRWxlbSwgd2luZG93LCBpbmNsdWRlSGlkZGVuRWxlbWVudHMsIGZhbHNlKSwgaGVhZCA9IF9iLmhlYWQsIGJvZHkgPSBfYi5ib2R5O1xuICAgICAgICB2YXIgY29sdW1ucyA9ICgoX2EgPSBoZWFkWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmNvbnRlbnQ7IH0pKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHsgY29sdW1uczogY29sdW1ucywgcm93czogYm9keSwgZGF0YTogYm9keSB9O1xuICAgIH07XG59XG5cbnZhciBfYTtcbmZ1bmN0aW9uIGF1dG9UYWJsZShkLCBvcHRpb25zKSB7XG4gICAgdmFyIGlucHV0ID0gcGFyc2VJbnB1dChkLCBvcHRpb25zKTtcbiAgICB2YXIgdGFibGUgPSBjcmVhdGVUYWJsZShkLCBpbnB1dCk7XG4gICAgZHJhd1RhYmxlKGQsIHRhYmxlKTtcbn1cbi8vIEV4cGVyaW1lbnRhbCBleHBvcnRcbmZ1bmN0aW9uIF9fY3JlYXRlVGFibGUoZCwgb3B0aW9ucykge1xuICAgIHZhciBpbnB1dCA9IHBhcnNlSW5wdXQoZCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNyZWF0ZVRhYmxlKGQsIGlucHV0KTtcbn1cbmZ1bmN0aW9uIF9fZHJhd1RhYmxlKGQsIHRhYmxlKSB7XG4gICAgZHJhd1RhYmxlKGQsIHRhYmxlKTtcbn1cbnRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB2YXIgYW55V2luZG93ID0gd2luZG93O1xuICAgICAgICB2YXIganNQREYgPSBhbnlXaW5kb3cuanNQREYgfHwgKChfYSA9IGFueVdpbmRvdy5qc3BkZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmpzUERGKTtcbiAgICAgICAgaWYgKGpzUERGKSB7XG4gICAgICAgICAgICBhcHBseVBsdWdpbihqc1BERik7XG4gICAgICAgIH1cbiAgICB9XG59XG5jYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdDb3VsZCBub3QgYXBwbHkgYXV0b1RhYmxlIHBsdWdpbicsIGVycm9yKTtcbn1cblxuZXhwb3J0IHsgQ2VsbCwgQ2VsbEhvb2tEYXRhLCBDb2x1bW4sIEhvb2tEYXRhLCBSb3csIFRhYmxlLCBfX2NyZWF0ZVRhYmxlLCBfX2RyYXdUYWJsZSwgYXBwbHlQbHVnaW4sIGF1dG9UYWJsZSwgYXV0b1RhYmxlIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJhdXRvVGFibGVUZXh0IiwidGV4dCIsIngiLCJ5Iiwic3R5bGVzIiwiZG9jIiwiUEhZU0lDQUxfTElORV9IRUlHSFQiLCJrIiwiaW50ZXJuYWwiLCJzY2FsZUZhY3RvciIsImZvbnRTaXplIiwiZ2V0Rm9udFNpemUiLCJsaW5lSGVpZ2h0RmFjdG9yIiwiZ2V0TGluZUhlaWdodEZhY3RvciIsImxpbmVIZWlnaHQiLCJzcGxpdFJlZ2V4Iiwic3BsaXRUZXh0IiwibGluZUNvdW50IiwidmFsaWduIiwiaGFsaWduIiwic3BsaXQiLCJsZW5ndGgiLCJhbGlnblNpemUiLCJpTGluZSIsImdldFN0cmluZ1VuaXRXaWR0aCIsIm1heFdpZHRoIiwiYWxpZ24iLCJnbG9iYWxEZWZhdWx0cyIsIkRvY0hhbmRsZXIiLCJqc1BERkRvY3VtZW50IiwidXNlclN0eWxlcyIsInRleHRDb2xvciIsImdldFRleHRDb2xvciIsImZvbnRTdHlsZSIsImdldEZvbnQiLCJmb250IiwiZm9udE5hbWUiLCJsaW5lV2lkdGgiLCJnZXRMaW5lV2lkdGgiLCJsaW5lQ29sb3IiLCJnZXREcmF3Q29sb3IiLCJzZXREZWZhdWx0cyIsImRlZmF1bHRzIiwiX19hdXRvVGFibGVEb2N1bWVudERlZmF1bHRzIiwidW5pZnlDb2xvciIsImMiLCJBcnJheSIsImlzQXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseVN0eWxlcyIsImZvbnRPbmx5IiwiX2EiLCJfYiIsIl9jIiwic2V0Rm9udFN0eWxlIiwiX2QiLCJhdmFpbGFibGVGb250U3R5bGVzIiwiZ2V0Rm9udExpc3QiLCJpbmRleE9mIiwic2V0Rm9udCIsInNldEZvbnRTaXplIiwiY29sb3IiLCJmaWxsQ29sb3IiLCJzZXRGaWxsQ29sb3IiLCJhcHBseSIsInNldFRleHRDb2xvciIsInNldERyYXdDb2xvciIsInNldExpbmVXaWR0aCIsInNwbGl0VGV4dFRvU2l6ZSIsInNpemUiLCJvcHRzIiwicmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiZmlsbFN0eWxlIiwiZ2V0TGFzdEF1dG9UYWJsZSIsImxhc3RBdXRvVGFibGUiLCJnZXRUZXh0V2lkdGgiLCJnZXREb2N1bWVudCIsInNldFBhZ2UiLCJwYWdlIiwiYWRkUGFnZSIsImdldEdsb2JhbE9wdGlvbnMiLCJnZXREb2N1bWVudE9wdGlvbnMiLCJwYWdlU2l6ZSIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwiZ2V0TGluZUhlaWdodCIsInBhZ2VOdW1iZXIiLCJwYWdlSW5mbyIsImdldEN1cnJlbnRQYWdlSW5mbyIsImdldE51bWJlck9mUGFnZXMiLCJleHRlbmRTdGF0aWNzIiwiZCIsImIiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfX2V4dGVuZHMiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJfXyIsImNvbnN0cnVjdG9yIiwiY3JlYXRlIiwiU3VwcHJlc3NlZEVycm9yIiwiZXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsImUiLCJFcnJvciIsIm5hbWUiLCJIdG1sUm93SW5wdXQiLCJfc3VwZXIiLCJlbGVtZW50IiwiX3RoaXMiLCJfZWxlbWVudCIsImRlZmF1bHRTdHlsZXMiLCJvdmVyZmxvdyIsImNlbGxQYWRkaW5nIiwiY2VsbFdpZHRoIiwibWluQ2VsbEhlaWdodCIsIm1pbkNlbGxXaWR0aCIsImdldFRoZW1lIiwidGhlbWVzIiwic3RyaXBlZCIsInRhYmxlIiwiaGVhZCIsImJvZHkiLCJmb290IiwiYWx0ZXJuYXRlUm93IiwiZ3JpZCIsInBsYWluIiwiZ2V0U3RyaW5nV2lkdGgiLCJ0ZXh0QXJyIiwid2lkZXN0TGluZVdpZHRoIiwibWFwIiwicmVkdWNlIiwiYSIsIk1hdGgiLCJtYXgiLCJhZGRUYWJsZUJvcmRlciIsInN0YXJ0UG9zIiwiY3Vyc29yIiwic2V0dGluZ3MiLCJ0YWJsZUxpbmVXaWR0aCIsInRhYmxlTGluZUNvbG9yIiwiZ2V0RmlsbFN0eWxlIiwiZHJhd0xpbmUiLCJkcmF3QmFja2dyb3VuZCIsInBhcnNlU3BhY2luZyIsInZhbHVlIiwiZGVmYXVsdFZhbHVlIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwidmVydGljYWwiLCJob3Jpem9udGFsIiwiZ2V0UGFnZUF2YWlsYWJsZVdpZHRoIiwibWFyZ2lucyIsIm1hcmdpbiIsInBhcnNlQ3NzIiwic3VwcG9ydGVkRm9udHMiLCJzdHlsZSIsIndpbmRvdyIsInJlc3VsdCIsInB4U2NhbGVGYWN0b3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJwYXJzZUNvbG9yIiwiZWxlbSIsImdldENvbXB1dGVkU3R5bGUiLCJwYWRkaW5nIiwicGFyc2VQYWRkaW5nIiwiYm9yZGVyQ29sb3JTaWRlIiwiZmluYWxTY2FsZUZhY3RvciIsImJ0dyIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJib3JkZXJSaWdodFdpZHRoIiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyV2lkdGgiLCJwYXJzZUZsb2F0IiwiYm9yZGVyQ29sb3IiLCJhY2NlcHRlZCIsInRleHRBbGlnbiIsInZlcnRpY2FsQWxpZ24iLCJyZXMiLCJwYXJzZUludCIsImlzTmFOIiwicGFyc2VGb250U3R5bGUiLCJmb250RmFtaWx5IiwidG9Mb3dlckNhc2UiLCJmb250V2VpZ2h0Iiwic3R5bGVHZXR0ZXIiLCJjc3NDb2xvciIsInJlYWxDb2xvciIsInJnYmEiLCJtYXRjaCIsImFscGhhIiwiYmciLCJwYXJlbnRFbGVtZW50IiwidmFsIiwicGFkZGluZ1RvcCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdCb3R0b20iLCJwYWRkaW5nTGVmdCIsImxpbmVQYWRkaW5nIiwiaW5wdXRQYWRkaW5nIiwibiIsInBhcnNlSHRtbCIsImlucHV0IiwiaW5jbHVkZUhpZGRlbkh0bWwiLCJ1c2VDc3MiLCJ0YWJsZUVsZW1lbnQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJrZXlzIiwiY29uc29sZSIsImkiLCJyb3dzIiwidGFnTmFtZSIsInJvdyIsInBhcnNlUm93Q29udGVudCIsInB1c2giLCJpbmNsdWRlSGlkZGVuIiwicmVzdWx0Um93IiwiY2VsbHMiLCJjZWxsIiwic3R5bGVfMSIsImRpc3BsYXkiLCJjZWxsU3R5bGVzIiwicm93U3BhbiIsImNvbFNwYW4iLCJjb250ZW50IiwicGFyc2VDZWxsQ29udGVudCIsIm9yZ0NlbGwiLCJjbG9uZU5vZGUiLCJpbm5lckhUTUwiLCJyZXBsYWNlIiwicGFydCIsInRyaW0iLCJqb2luIiwiaW5uZXJUZXh0IiwidGV4dENvbnRlbnQiLCJ2YWxpZGF0ZUlucHV0IiwiZ2xvYmFsIiwiY3VycmVudCIsIl9pIiwib3B0aW9ucyIsInN0YXJ0WSIsImFzc2lnbiIsInRhcmdldCIsInMiLCJzMSIsInMyIiwiczMiLCJ0byIsImluZGV4IiwiYXJndW1lbnRzIiwibmV4dFNvdXJjZSIsIm5leHRLZXkiLCJwYXJzZUlucHV0Iiwid2luIiwicGFyc2VTdHlsZXMiLCJob29rcyIsInBhcnNlSG9va3MiLCJwYXJzZVNldHRpbmdzIiwicGFyc2VDb250ZW50JDEiLCJpZCIsInRhYmxlSWQiLCJnSW5wdXQiLCJkSW5wdXQiLCJjSW5wdXQiLCJzdHlsZU9wdGlvbnMiLCJoZWFkU3R5bGVzIiwiYm9keVN0eWxlcyIsImZvb3RTdHlsZXMiLCJhbHRlcm5hdGVSb3dTdHlsZXMiLCJjb2x1bW5TdHlsZXMiLCJfbG9vcF8xIiwicHJvcCIsImdsb2JhbF8xIiwiZG9jdW1lbnRfMSIsImFsbE9wdGlvbnMiLCJkaWRQYXJzZUNlbGwiLCJ3aWxsRHJhd0NlbGwiLCJkaWREcmF3Q2VsbCIsIndpbGxEcmF3UGFnZSIsImRpZERyYXdQYWdlIiwiYWxsT3B0aW9uc18xIiwiX2UiLCJfZiIsIl9nIiwiX2giLCJfaiIsIl9rIiwiX2wiLCJfbSIsImdldFN0YXJ0WSIsInNob3dGb290Iiwic2hvd0hlYWQiLCJ0aGVtZSIsImhvcml6b250YWxQYWdlQnJlYWsiLCJob3Jpem9udGFsUGFnZUJyZWFrUmVwZWF0IiwicGFnZUJyZWFrIiwicm93UGFnZUJyZWFrIiwidGFibGVXaWR0aCIsImhvcml6b250YWxQYWdlQnJlYWtCZWhhdmlvdXIiLCJ1c2VyU3RhcnRZIiwicHJldmlvdXMiLCJzZiIsImN1cnJlbnRQYWdlIiwiaXNTYW1lUGFnZUFzUHJldmlvdXNUYWJsZSIsInN0YXJ0UGFnZU51bWJlciIsImVuZGluZ1BhZ2UiLCJmaW5hbFkiLCJodG1sIiwiaGlkZGVuIiwiaHRtbENvbnRlbnQiLCJjb2x1bW5zIiwicGFyc2VDb2x1bW5zIiwiZmlyc3RSb3ciLCJmaWx0ZXIiLCJrZXkiLCJmb3JFYWNoIiwiY29uY2F0Iiwicm93UmVzdWx0IiwiZGF0YUtleSIsIkhvb2tEYXRhIiwiQ2VsbEhvb2tEYXRhIiwiY29sdW1uIiwic2VjdGlvbiIsIlRhYmxlIiwiZ2V0SGVhZEhlaWdodCIsImFjYyIsImdldE1heENlbGxIZWlnaHQiLCJnZXRGb290SGVpZ2h0IiwiYWxsUm93cyIsImNhbGxDZWxsSG9va3MiLCJoYW5kbGVycyIsImhhbmRsZXJzXzEiLCJoYW5kbGVyIiwiZGF0YSIsImNhbGxFbmRQYWdlSG9va3MiLCJjYWxsV2lsbERyYXdQYWdlSG9va3MiLCJwYWdlV2lkdGgiLCJ3cmFwcGVkV2lkdGgiLCJ0b3RhbCIsImNvbCIsIlJvdyIsInJhdyIsInNwYW5zTXVsdGlwbGVQYWdlcyIsImhhc1Jvd1NwYW4iLCJjYW5FbnRpcmVSb3dGaXQiLCJnZXRNaW5pbXVtUm93SGVpZ2h0IiwidlBhZGRpbmciLCJvbmVSb3dIZWlnaHQiLCJDZWxsIiwiY29udGVudEhlaWdodCIsImNvbnRlbnRXaWR0aCIsIm1pblJlYWRhYmxlV2lkdGgiLCJtaW5XaWR0aCIsImdldFRleHRQb3MiLCJuZXRIZWlnaHQiLCJuZXRXaWR0aCIsImdldENvbnRlbnRIZWlnaHQiLCJDb2x1bW4iLCJnZXRNYXhDdXN0b21DZWxsV2lkdGgiLCJjYWxjdWxhdGVXaWR0aHMiLCJjYWxjdWxhdGUiLCJyZXNpemFibGVDb2x1bW5zIiwiaW5pdGlhbFRhYmxlV2lkdGgiLCJjdXN0b21XaWR0aCIsInJlc2l6ZVdpZHRoIiwicmVzaXplQ29sdW1ucyIsImFicyIsInJvdW5kIiwid2FybiIsImFwcGx5Q29sU3BhbnMiLCJmaXRDb250ZW50IiwiYXBwbHlSb3dTcGFucyIsImF2YWlsYWJsZVBhZ2VXaWR0aCIsImxvbmdlc3RXb3JkV2lkdGgiLCJkZWZhdWx0TWluV2lkdGgiLCJnZXRNaW5XaWR0aCIsImluaXRpYWxSZXNpemVXaWR0aCIsInN1bVdyYXBwZWRXaWR0aCIsInJhdGlvIiwic3VnZ2VzdGVkQ2hhbmdlIiwic3VnZ2VzdGVkV2lkdGgiLCJuZXdXaWR0aCIsInJvd1NwYW5DZWxscyIsImNvbFJvd1NwYW5zTGVmdCIsImFsbCIsInJvd0luZGV4IiwicmVtYWluaW5nIiwiY29sU3BhbkNlbGwiLCJjb21iaW5lZENvbFNwYW5XaWR0aCIsImNvbFNwYW5zTGVmdCIsImNvbHVtbkluZGV4Iiwicm93U3BhbkhlaWdodCIsImNvdW50IiwidGV4dFNwYWNlIiwiZWxsaXBzaXplIiwicmVhbENvbnRlbnRIZWlnaHQiLCJzdHIiLCJlbGxpcHNpemVTdHIiLCJwcmVjaXNpb24iLCJjZWlsIiwic3Vic3RyaW5nIiwiY3JlYXRlVGFibGUiLCJqc1BERkRvYyIsInBhcnNlQ29udGVudCIsImNyZWF0ZUNvbHVtbnMiLCJzZWN0aW9uUm93IiwiZ2VuZXJhdGVTZWN0aW9uUm93IiwicGFyc2VTZWN0aW9uIiwic2VjdGlvbk5hbWUiLCJzZWN0aW9uUm93cyIsInN0eWxlUHJvcHMiLCJyb3dTcGFuc0xlZnRGb3JDb2x1bW4iLCJyYXdSb3ciLCJza2lwcGVkUm93Rm9yUm93U3BhbnMiLCJjb2xTcGFuc0FkZGVkIiwiY29sdW1uU3BhbnNMZWZ0IiwiY29sdW1uc18xIiwicmF3Q2VsbCIsImNlbGxJbnB1dFN0eWxlcyIsInRpbWVzIiwidGl0bGUiLCJnZXRTZWN0aW9uVGl0bGUiLCJoZWFkZXIiLCJmb290ZXIiLCJ0aGVtZU5hbWUiLCJzZWN0aW9uU3R5bGVzIiwib3RoZXJTdHlsZXMiLCJjb2xTdHlsZXMiLCJyb3dTdHlsZXMiLCJkZWZhdWx0U3R5bGUiLCJ0aGVtZVN0eWxlcyIsImdldENvbHVtbnNDYW5GaXRJblBhZ2UiLCJjb25maWciLCJyZW1haW5pbmdXaWR0aCIsInJlcGVhdENvbHVtbnNNYXAiLCJNYXAiLCJjb2xJbmRleGVzIiwiZmllbGQiLCJmaW5kIiwiaXRlbSIsImhhcyIsInNldCIsImZpcnN0Iiwic3RhcnQiLCJjb2xXaWR0aCIsImxhc3RJbmRleCIsImNhbGN1bGF0ZUFsbENvbHVtbnNDYW5GaXRJblBhZ2UiLCJhbGxSZXN1bHRzIiwiZHJhd1RhYmxlIiwic2VjdGlvbnNIZWlnaHQiLCJtaW5UYWJsZUJvdHRvbVBvcyIsInRhYmxlSGVpZ2h0IiwibmV4dFBhZ2UiLCJwcmludFRhYmxlV2l0aEhvcml6b250YWxQYWdlQnJlYWsiLCJwcmludFJvdyIsImlzTGFzdFJvdyIsInByaW50RnVsbFJvdyIsImFsbENvbHVtbnNDYW5GaXRSZXN1bHQiLCJjb2xzQW5kSW5kZXhlcyIsInByaW50SGVhZCIsInByaW50Qm9keSIsInByaW50Rm9vdCIsImxhc3RSb3dJbmRleE9mTGFzdFBhZ2VfMSIsImZpcnN0Q29sdW1uc1RvRml0UmVzdWx0IiwibGFzdFByaW50ZWRSb3dJbmRleCIsImZpcnN0Q29sdW1uc1RvRml0IiwicHJpbnRCb2R5V2l0aG91dFBhZ2VCcmVha3MiLCJtYXhOdW1iZXJPZlJvd3MiLCJzbGljZSIsInN0YXJ0Um93SW5kZXgiLCJlbmRSb3dJbmRleCIsIm1pbiIsInJlbWFpbmluZ1NwYWNlIiwiZ2V0UmVtYWluaW5nUGFnZVNwYWNlIiwiZ2V0UmVtYWluaW5nTGluZUNvdW50IiwicmVtYWluaW5nUGFnZVNwYWNlIiwicmVtYWluaW5nTGluZXMiLCJmbG9vciIsIm1vZGlmeVJvd1RvRml0Iiwicm93SGVpZ2h0IiwicmVtYWluZGVyQ2VsbCIsInJlbWFpbmluZ0xpbmVDb3VudCIsInNwbGljZSIsInJlbWFpbmRlclJvdyIsInNob3VsZFByaW50T25DdXJyZW50UGFnZSIsInBhZ2VIZWlnaHQiLCJtYXJnaW5IZWlnaHQiLCJtYXhSb3dIZWlnaHQiLCJtaW5Sb3dIZWlnaHQiLCJtaW5Sb3dGaXRzIiwicm93SGFzUm93U3BhbkNlbGwiLCJyb3dIaWdoZXJUaGFuUGFnZSIsImRyYXdDZWxsUmVjdCIsInRleHRQb3MiLCJnZXRGaWxsQ29sb3IiLCJkcmF3Q2VsbEJvcmRlcnMiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImxpbmUiLCJib3R0b21Db250ZW50SGVpZ2h0Iiwic3VwcHJlc3NGb290ZXIiLCJuZXdDdXJyZW50IiwiYXBwbHlQbHVnaW4iLCJqc1BERiIsIkFQSSIsImF1dG9UYWJsZSIsImFyZ3MiLCJhdXRvVGFibGVTZXREZWZhdWx0cyIsImF1dG9UYWJsZUh0bWxUb0pzb24iLCJ0YWJsZUVsZW0iLCJpbmNsdWRlSGlkZGVuRWxlbWVudHMiLCJfX2NyZWF0ZVRhYmxlIiwiX19kcmF3VGFibGUiLCJhbnlXaW5kb3ciLCJqc3BkZiIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jspdf-autotable/dist/jspdf.plugin.autotable.mjs\n");

/***/ })

};
;